<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mod√®le JANUS ‚Äî Simulation Cosmologique Compl√®te</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --positive: #00d4ff;
            --positive-glow: rgba(0, 212, 255, 0.5);
            --negative: #ff6b35;
            --negative-glow: rgba(255, 107, 53, 0.5);
            --attract: #00ff88;
            --repel: #ff3366;
            --bg: #020406;
            --bg-panel: rgba(5, 10, 18, 0.97);
            --border: rgba(0, 212, 255, 0.15);
            --text: #e8eef4;
            --text-dim: #6b7280;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        /* Left Panel */
        .panel-left {
            position: fixed;
            top: 0;
            left: 0;
            width: 360px;
            height: 100vh;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            z-index: 100;
            overflow-y: auto;
            backdrop-filter: blur(20px);
        }

        /* Right Panel */
        .panel-right {
            position: fixed;
            top: 0;
            right: 0;
            width: 380px;
            height: 100vh;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            z-index: 100;
            overflow-y: auto;
            backdrop-filter: blur(20px);
        }

        .panel-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(0,212,255,0.06) 0%, transparent 100%);
        }

        .panel-title {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--positive), var(--negative));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .panel-subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 4px;
            letter-spacing: 0.5px;
        }

        .section {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-dim);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--positive);
            border-radius: 2px;
        }

        /* Laws */
        .laws-grid {
            display: grid;
            gap: 8px;
        }

        .law-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 11px;
        }

        .law-particles {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .dot.pos { background: var(--positive); box-shadow: 0 0 6px var(--positive-glow); }
        .dot.neg { background: var(--negative); box-shadow: 0 0 6px var(--negative-glow); }

        .law-arrow {
            font-weight: 700;
            font-size: 12px;
        }

        .law-arrow.attract { color: var(--attract); }
        .law-arrow.repel { color: var(--repel); }

        .law-text {
            color: var(--text-dim);
            flex: 1;
        }

        /* Scenarios */
        .scenario-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .scenario-btn {
            padding: 12px 10px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .scenario-btn:hover {
            border-color: var(--positive);
            background: rgba(0, 212, 255, 0.08);
        }

        .scenario-btn.active {
            border-color: var(--positive);
            background: rgba(0, 212, 255, 0.15);
            color: var(--positive);
        }

        .scenario-btn .icon {
            font-size: 18px;
            display: block;
            margin-bottom: 4px;
        }

        .scenario-btn.full {
            grid-column: span 2;
        }

        /* Controls */
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-label {
            font-size: 11px;
            color: var(--text-dim);
            min-width: 70px;
        }

        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--positive);
            min-width: 45px;
            text-align: right;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--positive);
            border-radius: 50%;
            cursor: pointer;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: var(--positive);
            background: rgba(0, 212, 255, 0.1);
        }

        .btn.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--positive);
            color: var(--positive);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
        }

        .stat-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
        }

        .stat-value.pos { color: var(--positive); }
        .stat-value.neg { color: var(--negative); }
        .stat-value.neutral { color: var(--text); }
        .stat-value.attract { color: var(--attract); }
        .stat-value.repel { color: var(--repel); }

        /* Force Counter */
        .force-counter {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 12px;
        }

        .force-box {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .force-box.attract {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .force-box.repel {
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid rgba(255, 51, 102, 0.3);
        }

        .force-label {
            font-size: 10px;
            color: var(--text-dim);
            margin-bottom: 4px;
        }

        .force-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 700;
        }

        .force-box.attract .force-value { color: var(--attract); }
        .force-box.repel .force-value { color: var(--repel); }

        /* Explanation */
        .explanation-box {
            background: linear-gradient(135deg, rgba(0,212,255,0.08), rgba(255,107,53,0.08));
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
        }

        .explanation-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .explanation-text {
            font-size: 11px;
            color: var(--text-dim);
            line-height: 1.6;
        }

        .explanation-text strong {
            color: var(--text);
        }

        .hl-pos { color: var(--positive); font-weight: 600; }
        .hl-neg { color: var(--negative); font-weight: 600; }
        .hl-attract { color: var(--attract); font-weight: 600; }
        .hl-repel { color: var(--repel); font-weight: 600; }

        /* Live Events */
        .events-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .event-item {
            font-size: 10px;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            border-left: 3px solid var(--positive);
        }

        .event-item.attraction { border-left-color: var(--attract); }
        .event-item.repulsion { border-left-color: var(--repel); }
        .event-item.structure { border-left-color: var(--positive); }

        /* Info bar */
        .info-bar {
            position: fixed;
            top: 20px;
            left: 380px;
            right: 400px;
            padding: 12px 20px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: var(--positive);
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 380px;
            padding: 12px 16px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(20px);
            display: flex;
            gap: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--text-dim);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Scrollbar */
        .panel-left::-webkit-scrollbar,
        .panel-right::-webkit-scrollbar {
            width: 5px;
        }

        .panel-left::-webkit-scrollbar-track,
        .panel-right::-webkit-scrollbar-track {
            background: transparent;
        }

        .panel-left::-webkit-scrollbar-thumb,
        .panel-right::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Left Panel -->
    <div class="panel-left">
        <div class="panel-header">
            <div class="panel-title">Mod√®le JANUS</div>
            <div class="panel-subtitle">Cosmologie Bim√©trique ‚Ä¢ J.P. Petit</div>
        </div>

        <!-- Janus Laws -->
        <div class="section">
            <div class="section-title">Lois d'Interaction Janus</div>
            <div class="laws-grid">
                <div class="law-item">
                    <div class="law-particles">
                        <div class="dot pos"></div>
                        <span>+</span>
                        <div class="dot pos"></div>
                    </div>
                    <div class="law-arrow attract">‚Üí</div>
                    <div class="law-text">S'attirent</div>
                </div>
                <div class="law-item">
                    <div class="law-particles">
                        <div class="dot neg"></div>
                        <span>+</span>
                        <div class="dot neg"></div>
                    </div>
                    <div class="law-arrow attract">‚Üí</div>
                    <div class="law-text">S'attirent</div>
                </div>
                <div class="law-item">
                    <div class="law-particles">
                        <div class="dot pos"></div>
                        <span>+</span>
                        <div class="dot neg"></div>
                    </div>
                    <div class="law-arrow repel">‚áÑ</div>
                    <div class="law-text">Se repoussent</div>
                </div>
            </div>
        </div>

        <!-- Scenarios -->
        <div class="section">
            <div class="section-title">Sc√©narios</div>
            <div class="scenario-grid">
                <button class="scenario-btn active full" id="scenario-lattice" onclick="loadScenario('lattice')">
                    <span class="icon">üî∑üî∂üî∑üî∂</span>
                    Maillage Alternant (√âquilibre Janus)
                </button>
                <button class="scenario-btn" id="scenario-cosmicweb" onclick="loadScenario('cosmicweb')">
                    <span class="icon">üï∏Ô∏è</span>
                    Toile Cosmique
                </button>
                <button class="scenario-btn" id="scenario-galaxy" onclick="loadScenario('galaxy')">
                    <span class="icon">üåÄ</span>
                    Galaxie + Halo
                </button>
                <button class="scenario-btn" id="scenario-confinement" onclick="loadScenario('confinement')">
                    <span class="icon">‚öõÔ∏è</span>
                    Confinement
                </button>
                <button class="scenario-btn" id="scenario-dipole" onclick="loadScenario('dipole')">
                    <span class="icon">üîÆ</span>
                    Dipole Repeller
                </button>
                <button class="scenario-btn" id="scenario-collision" onclick="loadScenario('collision')">
                    <span class="icon">üí•</span>
                    Collision
                </button>
                <button class="scenario-btn" id="scenario-expansion" onclick="loadScenario('expansion')">
                    <span class="icon">üåå</span>
                    Expansion
                </button>
                <button class="scenario-btn" id="scenario-filament" onclick="loadScenario('filament')">
                    <span class="icon">„Ä∞Ô∏è</span>
                    Filament
                </button>
                <button class="scenario-btn" id="scenario-cluster" onclick="loadScenario('cluster')">
                    <span class="icon">‚ú®</span>
                    Amas + Vides
                </button>
            </div>
        </div>

        <!-- Controls -->
        <div class="section">
            <div class="section-title">Param√®tres</div>
            
            <div class="control-row">
                <span class="control-label">Gravit√© G</span>
                <input type="range" id="ctrl-g" min="0.1" max="3" step="0.1" value="1">
                <span class="control-value" id="g-value">1.0</span>
            </div>

            <div class="control-row">
                <span class="control-label">Vitesse</span>
                <input type="range" id="ctrl-speed" min="0.1" max="2" step="0.1" value="0.5">
                <span class="control-value" id="speed-value">0.5√ó</span>
            </div>

            <div class="control-row">
                <span class="control-label">Particules</span>
                <input type="range" id="ctrl-particles" min="50" max="500" step="25" value="200">
                <span class="control-value" id="particles-value">200</span>
            </div>

            <div class="btn-row" style="margin-top: 14px;">
                <button class="btn active" id="btn-play" onclick="togglePause()">‚è∏ Pause</button>
                <button class="btn" onclick="resetSimulation()">‚Ü∫ Reset</button>
            </div>

            <div class="btn-row" style="margin-top: 8px;">
                <button class="btn" id="btn-trails" onclick="toggleTrails()">Tra√Æn√©es</button>
                <button class="btn active" id="btn-forces" onclick="toggleForces()">Forces</button>
                <button class="btn" id="btn-links" onclick="toggleLinks()">Liens</button>
            </div>
        </div>

        <!-- Stats -->
        <div class="section">
            <div class="section-title">Statistiques</div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Masses +</div>
                    <div class="stat-value pos" id="stat-pos">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Masses ‚àí</div>
                    <div class="stat-value neg" id="stat-neg">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">√ânergie Cin.</div>
                    <div class="stat-value neutral" id="stat-kinetic">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">S√©paration</div>
                    <div class="stat-value neutral" id="stat-sep">0</div>
                </div>
            </div>

            <div class="force-counter">
                <div class="force-box attract">
                    <div class="force-label">Attractions</div>
                    <div class="force-value" id="count-attract">0</div>
                </div>
                <div class="force-box repel">
                    <div class="force-label">R√©pulsions</div>
                    <div class="force-value" id="count-repel">0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Panel -->
    <div class="panel-right">
        <div class="panel-header">
            <div class="panel-title">Analyse en Direct</div>
            <div class="panel-subtitle">Comportement du syst√®me</div>
        </div>

        <!-- Current Explanation -->
        <div class="section">
            <div class="section-title">Ce Qui Se Passe</div>
            <div class="explanation-box">
                <div class="explanation-title">üí° <span id="scenario-title">Maillage Alternant</span></div>
                <div class="explanation-text" id="explanation-text">
                    Chargement...
                </div>
            </div>
        </div>

        <!-- Physics Explanation -->
        <div class="section">
            <div class="section-title">Physique Observ√©e</div>
            <div class="explanation-box" style="background: rgba(0,0,0,0.3);">
                <div class="explanation-text" id="physics-text">
                    Analyse en cours...
                </div>
            </div>
        </div>

        <!-- Live Events -->
        <div class="section">
            <div class="section-title">√âv√©nements en Direct</div>
            <div class="events-list" id="events-list">
                <div class="event-item structure">Simulation initialis√©e</div>
            </div>
        </div>

        <!-- Force Details -->
        <div class="section">
            <div class="section-title">D√©tail des Forces</div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Force Moy. Attract.</div>
                    <div class="stat-value attract" id="avg-attract">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Force Moy. R√©pul.</div>
                    <div class="stat-value repel" id="avg-repel">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Force Totale</div>
                    <div class="stat-value neutral" id="total-force">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">√âquilibre</div>
                    <div class="stat-value neutral" id="equilibrium">--</div>
                </div>
            </div>
        </div>

        <!-- Structure Analysis -->
        <div class="section">
            <div class="section-title">Analyse Structurelle</div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Clusters +</div>
                    <div class="stat-value pos" id="clusters-pos">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Clusters ‚àí</div>
                    <div class="stat-value neg" id="clusters-neg">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Densit√© Centre</div>
                    <div class="stat-value neutral" id="density-center">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Rayon Moyen</div>
                    <div class="stat-value neutral" id="avg-radius">0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Bar -->
    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">Temps</div>
            <div class="info-value" id="sim-time">t = 0.0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Particules</div>
            <div class="info-value" id="particle-count">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Interactions</div>
            <div class="info-value" id="interaction-count">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">FPS</div>
            <div class="info-value" id="fps">60</div>
        </div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background: var(--positive);"></div>
            <span>Masse + (visible)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: var(--negative);"></div>
            <span>Masse ‚àí (invisible)</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: var(--attract);"></div>
            <span>Attraction</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: var(--repel);"></div>
            <span>R√©pulsion</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // JANUS COSMOLOGICAL MODEL - COMPLETE SIMULATION
        // ============================================

        const CONFIG = {
            G: 1.0,
            SOFTENING: 3.0,
            DT: 0.016,
            SPEED: 0.5,
            DAMPING: 0.995,
            BOUNDS: 200,
            TRAIL_LENGTH: 40,
            MAX_FORCE: 8.0,
            N_PARTICLES: 200,
            MASS_RANGE: [1, 2]
        };

        // Three.js Setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020406);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 120, 250);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x404050, 0.6));
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 500);
        pointLight.position.set(50, 100, 50);
        scene.add(pointLight);

        // Particle Class
        class Particle {
            constructor(mass, position, velocity) {
                this.mass = mass;
                this.position = position.clone();
                this.velocity = velocity.clone();
                this.force = new THREE.Vector3();
                this.trail = [];
            }
        }

        // State
        let particles = [];
        let particleMeshes = [];
        let trails = [];
        let forceLines = new THREE.Group();
        let linkLines = new THREE.Group();
        scene.add(forceLines);
        scene.add(linkLines);

        let isPaused = false;
        let showTrails = false;
        let showForces = true;
        let showLinks = false;
        let simTime = 0;
        let frameCount = 0;
        let lastFpsTime = performance.now();

        // Force counters
        let attractionCount = 0;
        let repulsionCount = 0;
        let totalAttractionForce = 0;
        let totalRepulsionForce = 0;

        // Explanations
        const SCENARIOS = {
            lattice: {
                title: "Maillage Alternant (√âquilibre Janus)",
                text: `Structure fondamentale du mod√®le Janus : les <span class="hl-pos">masses positives</span> et <span class="hl-neg">masses n√©gatives</span> 
                sont dispos√©es en alternance (<span class="hl-pos">bleu</span>-<span class="hl-neg">orange</span>-<span class="hl-pos">bleu</span>-<span class="hl-neg">orange</span>...).
                <br><br>
                <strong>Chaque particule est :</strong><br>
                ‚Ä¢ <span class="hl-attract">Attir√©e</span> par les particules de m√™me signe (plus loin)<br>
                ‚Ä¢ <span class="hl-repel">Repouss√©e</span> par ses voisines imm√©diates (signe oppos√©)<br><br>
                Ce maillage cr√©e un <strong>√©quilibre dynamique</strong> o√π les forces s'√©quilibrent. 
                C'est ce qui maintient la structure √† grande √©chelle de l'univers selon Janus.`
            },
            cosmicweb: {
                title: "Toile Cosmique",
                text: `La structure √† grande √©chelle de l'univers : les <span class="hl-pos">galaxies (masses +)</span> forment des 
                <strong>filaments</strong> et des <strong>murs</strong>, tandis que les <span class="hl-neg">masses n√©gatives</span> 
                remplissent les <strong>vides cosmiques</strong>.
                <br><br>
                La <span class="hl-repel">r√©pulsion mutuelle</span> entre masses + et ‚àí cr√©e cette s√©gr√©gation naturelle.
                Les masses n√©gatives "poussent" la mati√®re visible dans des structures connect√©es.`
            },
            galaxy: {
                title: "Galaxie avec Halo N√©gatif",
                text: `Une <span class="hl-pos">galaxie spirale</span> entour√©e d'un <span class="hl-neg">halo de masse n√©gative</span>.
                <br><br>
                <strong>Le halo n√©gatif :</strong><br>
                ‚Ä¢ <span class="hl-repel">Confine</span> la galaxie par r√©pulsion<br>
                ‚Ä¢ Explique les <strong>courbes de rotation plates</strong><br>
                ‚Ä¢ Remplace la "mati√®re noire" hypoth√©tique<br><br>
                Les √©toiles en p√©riph√©rie tournent plus vite que pr√©vu car le halo n√©gatif les "pousse" vers l'int√©rieur.`
            },
            confinement: {
                title: "Confinement par Masse N√©gative",
                text: `Les <span class="hl-neg">masses n√©gatives</span> forment une "coquille" qui <span class="hl-repel">compresse</span> 
                les <span class="hl-pos">masses positives</span> au centre.
                <br><br>
                Ce m√©canisme explique la <strong>formation rapide des galaxies</strong> dans l'univers primordial :
                les masses n√©gatives ont agi comme des "murs" qui ont concentr√© et compress√© la mati√®re visible,
                acc√©l√©rant la formation des premi√®res structures.`
            },
            dipole: {
                title: "Dipole Repeller",
                text: `Un grand <span class="hl-neg">conglom√©rat de masse n√©gative</span> au centre <span class="hl-repel">repousse</span> 
                toutes les <span class="hl-pos">galaxies environnantes</span>.
                <br><br>
                Ce ph√©nom√®ne a √©t√© <strong>observ√©</strong> dans notre voisinage cosmique : notre groupe local de galaxies 
                semble "fuir" une r√©gion appel√©e le <strong>Dipole Repeller</strong>. 
                Janus pr√©dit que cette r√©gion contient une concentration de masse n√©gative.`
            },
            collision: {
                title: "Collision de Structures",
                text: `Deux <span class="hl-pos">amas de masses positives</span> entrent en collision, 
                chacun entour√© de son <span class="hl-neg">halo n√©gatif</span>.
                <br><br>
                Observez comment les halos n√©gatifs <span class="hl-repel">interagissent</span> : 
                ils se repoussent mais leurs masses positives centrales s'attirent.
                Ce type de collision r√©v√®le la structure bim√©trique de l'univers.`
            },
            expansion: {
                title: "Expansion Cosmique",
                text: `Distribution uniforme initiale qui <strong>√©volue spontan√©ment</strong> vers une structure lacunaire.
                <br><br>
                Les <span class="hl-neg">masses n√©gatives</span> <span class="hl-repel">repoussent</span> les <span class="hl-pos">masses positives</span>,
                cr√©ant des <strong>vides</strong> qui grandissent. Les masses positives sont "chass√©es" vers les bords,
                formant des <strong>filaments</strong>.
                <br><br>
                C'est l'<strong>expansion acc√©l√©r√©e</strong> de l'univers expliqu√©e sans "√©nergie noire".`
            },
            filament: {
                title: "Formation de Filament",
                text: `Les <span class="hl-pos">masses positives</span> sont align√©es en un <strong>filament</strong>, 
                "confin√©es" entre deux r√©gions de <span class="hl-neg">masses n√©gatives</span>.
                <br><br>
                Ce confinement lat√©ral explique pourquoi les galaxies forment des <strong>structures filamentaires</strong>
                plut√¥t que des distributions sph√©riques. Les masses n√©gatives agissent comme des "murs" qui canalisent la mati√®re visible.`
            },
            cluster: {
                title: "Amas et Vides",
                text: `Plusieurs <span class="hl-pos">amas de masses positives</span> s√©par√©s par des <span class="hl-neg">vides 
                remplis de masse n√©gative</span>.
                <br><br>
                Structure typique observ√©e dans l'univers : les amas de galaxies sont s√©par√©s par d'immenses vides.
                Dans Janus, ces vides ne sont pas "vides" mais remplis de masse n√©gative qui <span class="hl-repel">maintient la s√©paration</span>.`
            }
        };

        // ============================================
        // JANUS PHYSICS - CORRECT LAWS
        // ============================================

        function computeJanusForces() {
            particles.forEach(p => p.force.set(0, 0, 0));
            
            attractionCount = 0;
            repulsionCount = 0;
            totalAttractionForce = 0;
            totalRepulsionForce = 0;

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const r = new THREE.Vector3().subVectors(p2.position, p1.position);
                    const dist = Math.max(r.length(), CONFIG.SOFTENING);
                    
                    // JANUS LAWS:
                    // Same sign (both + or both -): ATTRACTION
                    // Opposite signs (+ and -): REPULSION
                    
                    const sameSign = (p1.mass > 0 && p2.mass > 0) || (p1.mass < 0 && p2.mass < 0);
                    const absM1 = Math.abs(p1.mass);
                    const absM2 = Math.abs(p2.mass);
                    
                    let forceMag = CONFIG.G * absM1 * absM2 / (dist * dist);
                    
                    if (sameSign) {
                        // Attraction: positive force (toward each other)
                        attractionCount++;
                        totalAttractionForce += forceMag;
                    } else {
                        // Repulsion: negative force (away from each other)
                        forceMag = -forceMag;
                        repulsionCount++;
                        totalRepulsionForce += Math.abs(forceMag);
                    }
                    
                    // Clamp
                    forceMag = Math.sign(forceMag) * Math.min(Math.abs(forceMag), CONFIG.MAX_FORCE);
                    
                    const forceDir = r.clone().normalize();
                    const force = forceDir.multiplyScalar(forceMag);
                    
                    // Newton's 3rd law
                    p1.force.add(force);
                    p2.force.sub(force);
                }
            }
        }

        function integrateMotion() {
            const dt = CONFIG.DT * CONFIG.SPEED;
            
            particles.forEach(p => {
                const accel = p.force.clone().divideScalar(Math.abs(p.mass));
                
                p.velocity.add(accel.multiplyScalar(dt));
                p.velocity.multiplyScalar(CONFIG.DAMPING);
                p.position.add(p.velocity.clone().multiplyScalar(dt));
                
                // Soft boundary
                const dist = p.position.length();
                if (dist > CONFIG.BOUNDS) {
                    p.position.multiplyScalar(CONFIG.BOUNDS / dist);
                    p.velocity.multiplyScalar(0.8);
                }
                
                // Trail
                if (showTrails) {
                    p.trail.push(p.position.clone());
                    if (p.trail.length > CONFIG.TRAIL_LENGTH) p.trail.shift();
                }
            });
        }

        // ============================================
        // VISUALS
        // ============================================

        function updateVisuals() {
            particles.forEach((p, i) => {
                particleMeshes[i].position.copy(p.position);
                
                if (showTrails && p.trail.length > 1) {
                    const positions = new Float32Array(p.trail.length * 3);
                    p.trail.forEach((pos, j) => {
                        positions[j * 3] = pos.x;
                        positions[j * 3 + 1] = pos.y;
                        positions[j * 3 + 2] = pos.z;
                    });
                    trails[i].geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    trails[i].geometry.computeBoundingSphere();
                }
                trails[i].visible = showTrails;
            });
            
            updateForceVectors();
            updateLinkLines();
        }

        function updateForceVectors() {
            forceLines.clear();
            if (!showForces) return;
            
            particles.forEach(p => {
                if (p.force.length() < 0.05) return;
                
                const dir = p.force.clone().normalize();
                const len = Math.min(p.force.length() * 4, 20);
                
                // Determine if net force is attraction or repulsion based on direction
                // For visualization, we color based on whether force is toward or away from nearest opposite-sign particle
                let nearestOpposite = null;
                let minDist = Infinity;
                
                particles.forEach(other => {
                    if (other === p) return;
                    if ((p.mass > 0) === (other.mass > 0)) return; // Same sign
                    const d = p.position.distanceTo(other.position);
                    if (d < minDist) {
                        minDist = d;
                        nearestOpposite = other;
                    }
                });
                
                let color;
                if (nearestOpposite) {
                    const toOpposite = new THREE.Vector3().subVectors(nearestOpposite.position, p.position).normalize();
                    const dot = p.force.clone().normalize().dot(toOpposite);
                    // If force points toward opposite sign particle, it's net attraction to same-sign
                    // If force points away from opposite sign, it's net repulsion from opposite-sign
                    color = dot < 0 ? 0xff3366 : 0x00ff88; // Away = repulsion (red), toward = attraction effect (green)
                } else {
                    color = 0x00ff88;
                }
                
                const points = [
                    p.position.clone(),
                    p.position.clone().add(dir.multiplyScalar(len))
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.7 });
                forceLines.add(new THREE.Line(geometry, material));
            });
        }

        function updateLinkLines() {
            linkLines.clear();
            if (!showLinks) return;
            
            const maxDist = 50;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const dist = p1.position.distanceTo(p2.position);
                    if (dist > maxDist) continue;
                    
                    const sameSign = (p1.mass > 0) === (p2.mass > 0);
                    const opacity = 0.3 * (1 - dist / maxDist);
                    const color = sameSign ? 0x00ff88 : 0xff3366;
                    
                    const points = [p1.position.clone(), p2.position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
                    linkLines.add(new THREE.Line(geometry, material));
                }
            }
        }

        // ============================================
        // STATISTICS
        // ============================================

        function updateStatistics() {
            const posParticles = particles.filter(p => p.mass > 0);
            const negParticles = particles.filter(p => p.mass < 0);
            
            document.getElementById('stat-pos').textContent = posParticles.length;
            document.getElementById('stat-neg').textContent = negParticles.length;
            
            // Kinetic energy
            const kinetic = particles.reduce((sum, p) => sum + 0.5 * Math.abs(p.mass) * p.velocity.lengthSq(), 0);
            document.getElementById('stat-kinetic').textContent = kinetic.toFixed(1);
            
            // Separation
            if (posParticles.length > 0 && negParticles.length > 0) {
                const comPos = new THREE.Vector3();
                const comNeg = new THREE.Vector3();
                let totalMassPos = 0, totalMassNeg = 0;
                
                posParticles.forEach(p => {
                    comPos.add(p.position.clone().multiplyScalar(p.mass));
                    totalMassPos += p.mass;
                });
                comPos.divideScalar(totalMassPos);
                
                negParticles.forEach(p => {
                    comNeg.add(p.position.clone().multiplyScalar(Math.abs(p.mass)));
                    totalMassNeg += Math.abs(p.mass);
                });
                comNeg.divideScalar(totalMassNeg);
                
                document.getElementById('stat-sep').textContent = comPos.distanceTo(comNeg).toFixed(1);
            }
            
            // Force counts
            document.getElementById('count-attract').textContent = attractionCount;
            document.getElementById('count-repel').textContent = repulsionCount;
            
            // Force averages
            const avgAttract = attractionCount > 0 ? totalAttractionForce / attractionCount : 0;
            const avgRepel = repulsionCount > 0 ? totalRepulsionForce / repulsionCount : 0;
            document.getElementById('avg-attract').textContent = avgAttract.toFixed(3);
            document.getElementById('avg-repel').textContent = avgRepel.toFixed(3);
            document.getElementById('total-force').textContent = (totalAttractionForce - totalRepulsionForce).toFixed(2);
            
            // Equilibrium
            const ratio = totalRepulsionForce > 0 ? totalAttractionForce / totalRepulsionForce : 0;
            let eqStatus = '--';
            if (ratio > 0.9 && ratio < 1.1) eqStatus = '‚âà √âquilibr√©';
            else if (ratio > 1.1) eqStatus = 'Attraction >';
            else if (ratio < 0.9 && ratio > 0) eqStatus = 'R√©pulsion >';
            document.getElementById('equilibrium').textContent = eqStatus;
            
            // Cluster analysis
            document.getElementById('clusters-pos').textContent = countClusters(posParticles);
            document.getElementById('clusters-neg').textContent = countClusters(negParticles);
            
            // Center density
            const centerRadius = 30;
            const centerCount = particles.filter(p => p.position.length() < centerRadius).length;
            document.getElementById('density-center').textContent = (centerCount / (4/3 * Math.PI * Math.pow(centerRadius, 3)) * 1000).toFixed(2);
            
            // Average radius
            const avgR = particles.reduce((sum, p) => sum + p.position.length(), 0) / particles.length;
            document.getElementById('avg-radius').textContent = avgR.toFixed(1);
            
            // Info bar
            document.getElementById('sim-time').textContent = `t = ${simTime.toFixed(1)}`;
            document.getElementById('particle-count').textContent = particles.length;
            document.getElementById('interaction-count').textContent = attractionCount + repulsionCount;
            
            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime > 1000) {
                document.getElementById('fps').textContent = Math.round(frameCount * 1000 / (now - lastFpsTime));
                frameCount = 0;
                lastFpsTime = now;
            }
            
            // Physics analysis
            updatePhysicsAnalysis();
        }

        function countClusters(particleList) {
            if (particleList.length === 0) return 0;
            
            const clusterDist = 25;
            const visited = new Set();
            let clusters = 0;
            
            particleList.forEach((p, i) => {
                if (visited.has(i)) return;
                
                // BFS to find cluster
                const queue = [i];
                visited.add(i);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    particleList.forEach((other, j) => {
                        if (visited.has(j)) return;
                        if (particleList[current].position.distanceTo(other.position) < clusterDist) {
                            visited.add(j);
                            queue.push(j);
                        }
                    });
                }
                
                clusters++;
            });
            
            return clusters;
        }

        function updatePhysicsAnalysis() {
            const posParticles = particles.filter(p => p.mass > 0);
            const negParticles = particles.filter(p => p.mass < 0);
            
            let analysis = '';
            
            // Analyze motion patterns
            const avgVelPos = posParticles.length > 0 ? 
                posParticles.reduce((sum, p) => sum + p.velocity.length(), 0) / posParticles.length : 0;
            const avgVelNeg = negParticles.length > 0 ?
                negParticles.reduce((sum, p) => sum + p.velocity.length(), 0) / negParticles.length : 0;
            
            if (avgVelPos < 0.5 && avgVelNeg < 0.5) {
                analysis += `<strong>√âtat quasi-stationnaire</strong> : Les particules se stabilisent. `;
            } else if (avgVelPos > avgVelNeg * 1.5) {
                analysis += `<strong>Masses + plus mobiles</strong> : Pouss√©es par les masses ‚àí. `;
            } else if (avgVelNeg > avgVelPos * 1.5) {
                analysis += `<strong>Masses ‚àí plus mobiles</strong> : S'√©loignent des masses +. `;
            }
            
            // Analyze structure
            const ratio = totalAttractionForce / (totalRepulsionForce + 0.001);
            if (ratio > 0.8 && ratio < 1.2) {
                analysis += `<span class="hl-attract">Forces √©quilibr√©es</span> ‚Üí structure stable. `;
            } else if (ratio > 1.2) {
                analysis += `<span class="hl-attract">Attraction dominante</span> ‚Üí collapse en cours. `;
            } else {
                analysis += `<span class="hl-repel">R√©pulsion dominante</span> ‚Üí expansion/s√©gr√©gation. `;
            }
            
            // Analyze segregation
            if (posParticles.length > 0 && negParticles.length > 0) {
                const comPos = new THREE.Vector3();
                const comNeg = new THREE.Vector3();
                posParticles.forEach(p => comPos.add(p.position));
                comPos.divideScalar(posParticles.length);
                negParticles.forEach(p => comNeg.add(p.position));
                comNeg.divideScalar(negParticles.length);
                
                const sep = comPos.distanceTo(comNeg);
                if (sep > 50) {
                    analysis += `<br><br>‚Üî <strong>S√©gr√©gation forte</strong> : Les populations sont bien s√©par√©es.`;
                } else if (sep > 20) {
                    analysis += `<br><br>‚Üî <strong>S√©gr√©gation mod√©r√©e</strong> : Structure en formation.`;
                } else {
                    analysis += `<br><br>‚Üî <strong>M√©lange</strong> : Les populations sont entrem√™l√©es.`;
                }
            }
            
            document.getElementById('physics-text').innerHTML = analysis || 'Analyse en cours...';
        }

        // ============================================
        // SCENARIOS
        // ============================================

        function clearParticles() {
            particles = [];
            particleMeshes.forEach(m => scene.remove(m));
            particleMeshes = [];
            trails.forEach(t => scene.remove(t));
            trails = [];
            forceLines.clear();
            linkLines.clear();
            simTime = 0;
            
            // Clear events
            document.getElementById('events-list').innerHTML = '<div class="event-item structure">Nouveau sc√©nario charg√©</div>';
        }

        function addParticle(mass, pos, vel) {
            const p = new Particle(mass, pos, vel);
            particles.push(p);
            
            const isPositive = mass > 0;
            const color = isPositive ? 0x00d4ff : 0xff6b35;
            const size = Math.cbrt(Math.abs(mass)) * 1.5;
            
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                metalness: 0.5,
                roughness: 0.4,
                transparent: true,
                opacity: 0.95
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            scene.add(mesh);
            particleMeshes.push(mesh);
            
            // Trail
            const trailGeom = new THREE.BufferGeometry();
            const trailMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
            const trail = new THREE.Line(trailGeom, trailMat);
            trail.visible = false;
            scene.add(trail);
            trails.push(trail);
        }

        function loadScenario(name) {
            clearParticles();
            
            // Update UI
            document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));
            const btnId = name === 'cosmicweb' ? 'scenario-cosmicweb' : `scenario-${name}`;
            document.getElementById(btnId)?.classList.add('active');
            
            const scenario = SCENARIOS[name];
            if (scenario) {
                document.getElementById('scenario-title').textContent = scenario.title;
                document.getElementById('explanation-text').innerHTML = scenario.text;
            }
            
            // Create scenario
            switch(name) {
                case 'lattice': createLattice(); break;
                case 'cosmicweb': createCosmicWeb(); break;
                case 'galaxy': createGalaxy(); break;
                case 'confinement': createConfinement(); break;
                case 'dipole': createDipole(); break;
                case 'collision': createCollision(); break;
                case 'expansion': createExpansion(); break;
                case 'filament': createFilament(); break;
                case 'cluster': createCluster(); break;
            }
            
            addEvent('structure', `Sc√©nario "${scenario?.title || name}" initialis√©`);
        }

        // ============================================
        // SCENARIO CREATORS
        // ============================================

        function createLattice() {
            // Create alternating 3D lattice: blue-orange-blue-orange
            const spacing = 20;
            const gridSize = 5;
            const offset = (gridSize - 1) * spacing / 2;
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        // Alternating pattern based on position parity
                        const isPositive = (x + y + z) % 2 === 0;
                        const mass = isPositive ? 
                            CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]) :
                            -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                        
                        const pos = new THREE.Vector3(
                            x * spacing - offset + (Math.random() - 0.5) * 2,
                            y * spacing - offset + (Math.random() - 0.5) * 2,
                            z * spacing - offset + (Math.random() - 0.5) * 2
                        );
                        
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2
                        );
                        
                        addParticle(mass, pos, vel);
                    }
                }
            }
        }

        function createCosmicWeb() {
            const n = Math.floor(CONFIG.N_PARTICLES / 2);
            
            // Create positive mass filaments
            const filamentCount = 6;
            for (let f = 0; f < filamentCount; f++) {
                const angle = (f / filamentCount) * Math.PI * 2;
                const perpAngle = angle + Math.PI / 2;
                
                for (let i = 0; i < n / filamentCount; i++) {
                    const t = (i / (n / filamentCount)) * 100 - 50;
                    const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                    
                    const pos = new THREE.Vector3(
                        t * Math.cos(angle) + (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15,
                        t * Math.sin(angle) + (Math.random() - 0.5) * 15
                    );
                    
                    const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3);
                    addParticle(mass, pos, vel);
                }
            }
            
            // Create negative mass in voids (between filaments and in center)
            for (let i = 0; i < n; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                // Place between filaments
                const voidAngle = (Math.floor(Math.random() * filamentCount) + 0.5) * (Math.PI * 2 / filamentCount);
                const r = 20 + Math.random() * 50;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(voidAngle) + (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 40,
                    r * Math.sin(voidAngle) + (Math.random() - 0.5) * 30
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.2);
                addParticle(mass, pos, vel);
            }
        }

        function createGalaxy() {
            const nPos = Math.floor(CONFIG.N_PARTICLES * 0.6);
            const nNeg = CONFIG.N_PARTICLES - nPos;
            
            // Spiral galaxy (positive mass)
            for (let i = 0; i < nPos; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                
                const arm = i % 2;
                const t = (i / nPos) * 3 * Math.PI;
                const r = 5 + t * 4;
                const theta = t + arm * Math.PI + (Math.random() - 0.5) * 0.4;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(theta) + (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 4,
                    r * Math.sin(theta) + (Math.random() - 0.5) * 6
                );
                
                // Orbital velocity
                const speed = Math.sqrt(CONFIG.G * 20 / Math.max(r, 5)) * 0.5;
                const vel = new THREE.Vector3(-speed * Math.sin(theta), 0, speed * Math.cos(theta));
                
                addParticle(mass, pos, vel);
            }
            
            // Negative mass halo
            for (let i = 0; i < nNeg; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 45 + Math.random() * 35;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) * 0.5,
                    r * Math.cos(phi)
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15);
                addParticle(mass, pos, vel);
            }
        }

        function createConfinement() {
            const nPos = Math.floor(CONFIG.N_PARTICLES * 0.4);
            const nNeg = CONFIG.N_PARTICLES - nPos;
            
            // Positive mass cloud in center
            for (let i = 0; i < nPos; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 35;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3);
                addParticle(mass, pos, vel);
            }
            
            // Negative mass shell compressing inward
            for (let i = 0; i < nNeg; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 55 + Math.random() * 25;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Inward velocity
                const vel = pos.clone().normalize().multiplyScalar(-0.4);
                addParticle(mass, pos, vel);
            }
        }

        function createDipole() {
            const nPos = Math.floor(CONFIG.N_PARTICLES * 0.6);
            const nNeg = CONFIG.N_PARTICLES - nPos;
            
            // Large negative mass concentration at center
            for (let i = 0; i < nNeg * 0.7; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0])) * 1.5;
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 25;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.1);
                addParticle(mass, pos, vel);
            }
            
            // Positive masses (galaxies) around, being repelled
            for (let i = 0; i < nPos; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 50 + Math.random() * 50;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Slight inward velocity (will be repelled)
                const vel = pos.clone().normalize().multiplyScalar(-0.2);
                addParticle(mass, pos, vel);
            }
            
            // Some negative in outer regions
            for (let i = 0; i < nNeg * 0.3; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 100 + Math.random() * 30;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.1);
                addParticle(mass, pos, vel);
            }
        }

        function createCollision() {
            const n = Math.floor(CONFIG.N_PARTICLES / 4);
            
            // Left cluster (positive with negative halo)
            for (let i = 0; i < n; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    -60 + (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25
                );
                const vel = new THREE.Vector3(1.5, 0, 0);
                addParticle(mass, pos, vel);
            }
            
            for (let i = 0; i < n * 0.5; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 25 + Math.random() * 15;
                const pos = new THREE.Vector3(
                    -60 + r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                const vel = new THREE.Vector3(1.5, 0, 0);
                addParticle(mass, pos, vel);
            }
            
            // Right cluster
            for (let i = 0; i < n; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    60 + (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25,
                    (Math.random() - 0.5) * 25
                );
                const vel = new THREE.Vector3(-1.5, 0, 0);
                addParticle(mass, pos, vel);
            }
            
            for (let i = 0; i < n * 0.5; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 25 + Math.random() * 15;
                const pos = new THREE.Vector3(
                    60 + r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                const vel = new THREE.Vector3(-1.5, 0, 0);
                addParticle(mass, pos, vel);
            }
        }

        function createExpansion() {
            const n = Math.floor(CONFIG.N_PARTICLES / 2);
            
            // Uniform initial distribution of both types
            for (let i = 0; i < n; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 60;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Positive mass
                const massPos = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const velPos = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3);
                addParticle(massPos, pos.clone(), velPos);
                
                // Negative mass nearby
                const offsetNeg = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(20);
                const massNeg = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const velNeg = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3);
                addParticle(massNeg, pos.clone().add(offsetNeg), velNeg);
            }
        }

        function createFilament() {
            const n = Math.floor(CONFIG.N_PARTICLES / 2);
            
            // Positive mass filament along X axis
            for (let i = 0; i < n; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    (i / n) * 150 - 75,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 15
                );
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.2);
                addParticle(mass, pos, vel);
            }
            
            // Negative mass on sides (confining walls)
            for (let i = 0; i < n; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const side = i % 2 === 0 ? 1 : -1;
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * 150,
                    side * (25 + Math.random() * 20),
                    (Math.random() - 0.5) * 50 + side * 20
                );
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15);
                addParticle(mass, pos, vel);
            }
        }

        function createCluster() {
            const n = Math.floor(CONFIG.N_PARTICLES / 6);
            
            // Multiple clusters of positive mass
            const clusterCenters = [
                new THREE.Vector3(-50, 30, 0),
                new THREE.Vector3(50, 30, 0),
                new THREE.Vector3(0, -30, -40),
                new THREE.Vector3(0, -30, 40)
            ];
            
            clusterCenters.forEach(center => {
                for (let i = 0; i < n; i++) {
                    const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                    const offset = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(30);
                    const pos = center.clone().add(offset);
                    const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3);
                    addParticle(mass, pos, vel);
                }
            });
            
            // Negative mass in voids (center and between clusters)
            for (let i = 0; i < n * 2; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                // Mostly in center
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 30;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.2);
                addParticle(mass, pos, vel);
            }
        }

        // ============================================
        // EVENTS
        // ============================================

        function addEvent(type, text) {
            const list = document.getElementById('events-list');
            const item = document.createElement('div');
            item.className = `event-item ${type}`;
            item.textContent = `[${simTime.toFixed(1)}] ${text}`;
            list.insertBefore(item, list.firstChild);
            
            // Keep only last 20 events
            while (list.children.length > 20) {
                list.removeChild(list.lastChild);
            }
        }

        let lastEventTime = 0;
        function checkEvents() {
            if (simTime - lastEventTime < 2) return;
            
            const posParticles = particles.filter(p => p.mass > 0);
            const negParticles = particles.filter(p => p.mass < 0);
            
            // Check for clustering
            const clustersPos = countClusters(posParticles);
            const clustersNeg = countClusters(negParticles);
            
            if (clustersPos === 1 && posParticles.length > 10) {
                addEvent('attraction', 'Masses + ont form√© un amas unique');
                lastEventTime = simTime;
            }
            
            // Check for separation
            if (posParticles.length > 0 && negParticles.length > 0) {
                const comPos = new THREE.Vector3();
                const comNeg = new THREE.Vector3();
                posParticles.forEach(p => comPos.add(p.position));
                comPos.divideScalar(posParticles.length);
                negParticles.forEach(p => comNeg.add(p.position));
                comNeg.divideScalar(negParticles.length);
                
                if (comPos.distanceTo(comNeg) > 80) {
                    addEvent('repulsion', 'Forte s√©gr√©gation des populations');
                    lastEventTime = simTime;
                }
            }
        }

        // ============================================
        // CAMERA CONTROLS
        // ============================================

        let cameraTheta = Math.PI / 4;
        let cameraPhi = Math.PI / 3;
        let cameraRadius = 250;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;

        function updateCamera() {
            camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = cameraRadius * Math.cos(cameraPhi);
            camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.lookAt(0, 0, 0);
        }

        renderer.domElement.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        renderer.domElement.addEventListener('mousemove', e => {
            if (!isDragging) return;
            cameraTheta -= (e.clientX - lastMouseX) * 0.005;
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + (e.clientY - lastMouseY) * 0.005));
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateCamera();
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);
        renderer.domElement.addEventListener('wheel', e => {
            cameraRadius = Math.max(80, Math.min(500, cameraRadius + e.deltaY * 0.5));
            updateCamera();
        });

        // ============================================
        // UI CONTROLS
        // ============================================

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('btn-play').textContent = isPaused ? '‚ñ∂ Play' : '‚è∏ Pause';
            document.getElementById('btn-play').classList.toggle('active', !isPaused);
        }

        function toggleTrails() {
            showTrails = !showTrails;
            document.getElementById('btn-trails').classList.toggle('active', showTrails);
            if (!showTrails) particles.forEach(p => p.trail = []);
        }

        function toggleForces() {
            showForces = !showForces;
            document.getElementById('btn-forces').classList.toggle('active', showForces);
        }

        function toggleLinks() {
            showLinks = !showLinks;
            document.getElementById('btn-links').classList.toggle('active', showLinks);
        }

        function resetSimulation() {
            const active = document.querySelector('.scenario-btn.active');
            if (active) {
                const name = active.id.replace('scenario-', '');
                loadScenario(name);
            }
        }

        // Sliders
        document.getElementById('ctrl-g').addEventListener('input', function() {
            CONFIG.G = parseFloat(this.value);
            document.getElementById('g-value').textContent = CONFIG.G.toFixed(1);
        });

        document.getElementById('ctrl-speed').addEventListener('input', function() {
            CONFIG.SPEED = parseFloat(this.value);
            document.getElementById('speed-value').textContent = CONFIG.SPEED.toFixed(1) + '√ó';
        });

        document.getElementById('ctrl-particles').addEventListener('input', function() {
            CONFIG.N_PARTICLES = parseInt(this.value);
            document.getElementById('particles-value').textContent = CONFIG.N_PARTICLES;
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused && particles.length > 0) {
                computeJanusForces();
                integrateMotion();
                updateVisuals();
                updateStatistics();
                checkEvents();
                simTime += CONFIG.DT * CONFIG.SPEED;
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        updateCamera();
        loadScenario('lattice');
        animate();
    </script>
</body>
</html>
