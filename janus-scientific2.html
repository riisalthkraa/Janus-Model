<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mod√®le Cosmologique JANUS ‚Äî Simulation Scientifique Avanc√©e</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --pos: #00b4d8;
            --pos-glow: rgba(0, 180, 216, 0.6);
            --neg: #ff6b35;
            --neg-glow: rgba(255, 107, 53, 0.6);
            --attract: #06ffa5;
            --repel: #ff2e63;
            --bg: #0a0a0f;
            --panel: rgba(12, 14, 20, 0.98);
            --card: rgba(20, 24, 35, 0.9);
            --border: rgba(0, 180, 216, 0.2);
            --text: #e4e8f0;
            --dim: #6c7386;
            --accent: #ffd700;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        /* Panels */
        .panel {
            position: fixed;
            top: 0;
            height: 100vh;
            background: var(--panel);
            z-index: 100;
            overflow-y: auto;
            backdrop-filter: blur(30px);
        }

        .panel-left {
            left: 0;
            width: 400px;
            border-right: 1px solid var(--border);
        }

        .panel-right {
            right: 0;
            width: 420px;
            border-left: 1px solid var(--border);
        }

        .panel::-webkit-scrollbar { width: 4px; }
        .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

        /* Header */
        .header {
            padding: 24px;
            background: linear-gradient(180deg, rgba(0,180,216,0.08) 0%, transparent 100%);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--pos), var(--neg));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--dim);
            letter-spacing: 0.5px;
        }

        /* Sections */
        .section {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--dim);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--pos);
            border-radius: 2px;
        }

        .section-badge {
            font-size: 9px;
            padding: 3px 8px;
            background: rgba(0,180,216,0.15);
            border: 1px solid rgba(0,180,216,0.3);
            border-radius: 4px;
            color: var(--pos);
        }

        /* Equations */
        .equation-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .equation-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .equation-content {
            font-size: 14px;
            color: var(--text);
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .equation-desc {
            font-size: 11px;
            color: var(--dim);
            line-height: 1.5;
        }

        /* Interaction Laws */
        .laws-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .law-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            transition: all 0.2s;
        }

        .law-card:hover {
            border-color: var(--pos);
            transform: translateX(4px);
        }

        .law-visual {
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 80px;
        }

        .particle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: relative;
        }

        .particle.pos {
            background: radial-gradient(circle at 30% 30%, #4dd9ff, var(--pos));
            box-shadow: 0 0 12px var(--pos-glow);
        }

        .particle.neg {
            background: radial-gradient(circle at 30% 30%, #ff9a6c, var(--neg));
            box-shadow: 0 0 12px var(--neg-glow);
        }

        .law-arrow {
            font-size: 16px;
            font-weight: 700;
        }

        .law-arrow.attract { color: var(--attract); }
        .law-arrow.repel { color: var(--repel); }

        .law-info { flex: 1; }

        .law-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .law-formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--dim);
        }

        /* Scenarios */
        .scenarios-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .scenario-btn {
            padding: 14px 12px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text);
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .scenario-btn:hover {
            border-color: var(--pos);
            background: rgba(0, 180, 216, 0.08);
        }

        .scenario-btn.active {
            border-color: var(--pos);
            background: rgba(0, 180, 216, 0.15);
            box-shadow: 0 0 20px rgba(0, 180, 216, 0.2);
        }

        .scenario-btn .icon {
            font-size: 18px;
            display: block;
            margin-bottom: 6px;
        }

        .scenario-btn .name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .scenario-btn .desc {
            font-size: 9px;
            color: var(--dim);
        }

        .scenario-btn.full {
            grid-column: span 2;
        }

        /* Controls */
        .control-group {
            margin-bottom: 16px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .control-label {
            font-size: 12px;
            color: var(--dim);
            min-width: 100px;
        }

        .control-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--pos);
            min-width: 50px;
            text-align: right;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--pos);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--pos-glow);
        }

        .btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .btn {
            padding: 12px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:hover {
            border-color: var(--pos);
            background: rgba(0, 180, 216, 0.1);
        }

        .btn.active {
            background: rgba(0, 180, 216, 0.2);
            border-color: var(--pos);
            color: var(--pos);
        }

        .btn.primary {
            background: linear-gradient(135deg, rgba(0,180,216,0.3), rgba(0,180,216,0.1));
            border-color: var(--pos);
        }

        .btn.full { grid-column: span 2; }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 14px;
        }

        .stat-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.pos { color: var(--pos); }
        .stat-value.neg { color: var(--neg); }
        .stat-value.attract { color: var(--attract); }
        .stat-value.repel { color: var(--repel); }
        .stat-value.neutral { color: var(--text); }
        .stat-value.accent { color: var(--accent); }

        .stat-unit {
            font-size: 10px;
            color: var(--dim);
            margin-left: 4px;
        }

        /* Force Balance */
        .force-balance {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 16px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            margin-top: 12px;
        }

        .force-bar-container {
            flex: 1;
            height: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .force-bar-attract {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--attract), rgba(6,255,165,0.5));
            border-radius: 6px 0 0 6px;
            transition: width 0.3s;
        }

        .force-bar-repel {
            position: absolute;
            right: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(270deg, var(--repel), rgba(255,46,99,0.5));
            border-radius: 0 6px 6px 0;
            transition: width 0.3s;
        }

        .force-label {
            font-size: 10px;
            font-weight: 600;
            min-width: 30px;
        }

        .force-label.attract { color: var(--attract); }
        .force-label.repel { color: var(--repel); }

        /* Explanation Panel */
        .explanation-card {
            background: linear-gradient(135deg, rgba(0,180,216,0.1), rgba(255,107,53,0.1));
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }

        .explanation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .explanation-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: rgba(255,215,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .explanation-title {
            font-size: 14px;
            font-weight: 600;
        }

        .explanation-text {
            font-size: 12px;
            color: var(--dim);
            line-height: 1.7;
        }

        .explanation-text strong { color: var(--text); }
        .hl-pos { color: var(--pos); font-weight: 600; }
        .hl-neg { color: var(--neg); font-weight: 600; }
        .hl-attract { color: var(--attract); font-weight: 600; }
        .hl-repel { color: var(--repel); font-weight: 600; }
        .hl-accent { color: var(--accent); font-weight: 600; }

        /* Physics Analysis */
        .analysis-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .analysis-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .analysis-content {
            font-size: 11px;
            color: var(--dim);
            line-height: 1.6;
        }

        /* Predictions */
        .prediction-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--pos);
        }

        .prediction-item.confirmed {
            border-left-color: var(--attract);
        }

        .prediction-item.pending {
            border-left-color: var(--accent);
        }

        .prediction-icon {
            font-size: 18px;
        }

        .prediction-text {
            flex: 1;
        }

        .prediction-title {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .prediction-desc {
            font-size: 10px;
            color: var(--dim);
        }

        .prediction-status {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }

        .prediction-status.confirmed {
            background: rgba(6,255,165,0.2);
            color: var(--attract);
        }

        .prediction-status.pending {
            background: rgba(255,215,0,0.2);
            color: var(--accent);
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 24px;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, var(--pos), var(--neg));
        }

        .timeline-item {
            position: relative;
            padding-bottom: 16px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 4px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--pos);
            border: 2px solid var(--bg);
        }

        .timeline-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--pos);
            margin-bottom: 4px;
        }

        .timeline-text {
            font-size: 11px;
            color: var(--dim);
        }

        /* Info Bar */
        .info-bar {
            position: fixed;
            top: 20px;
            left: 420px;
            right: 440px;
            padding: 14px 24px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            z-index: 100;
            backdrop-filter: blur(30px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-item { text-align: center; }

        .info-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: var(--pos);
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 420px;
            padding: 14px 20px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(30px);
            display: flex;
            gap: 24px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--dim);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-line {
            width: 24px;
            height: 3px;
            border-radius: 2px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--dim);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text);
            border-color: var(--pos);
        }

        .tab.active {
            background: rgba(0,180,216,0.15);
            border-color: var(--pos);
            color: var(--pos);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Left Panel -->
    <div class="panel panel-left">
        <div class="header">
            <div class="logo">
                <div class="logo-icon">üåå</div>
                <div>
                    <div class="title">JANUS</div>
                    <div class="subtitle">Mod√®le Cosmologique Bim√©trique</div>
                </div>
            </div>
        </div>

        <!-- Equations -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">√âquations Fondamentales</div>
                <div class="section-badge">J.P. Petit</div>
            </div>

            <div class="equation-card">
                <div class="equation-label">√âquations de Champ Coupl√©es</div>
                <div class="equation-content">
                    \(R_{\mu\nu} - \frac{1}{2}g_{\mu\nu}R = \chi\left(T_{\mu\nu} + \sqrt{\frac{|\bar{g}|}{|g|}}\bar{T}_{\mu\nu}\right)\)
                </div>
                <div class="equation-desc">
                    Deux m√©triques \(g_{\mu\nu}\) et \(\bar{g}_{\mu\nu}\) d√©crivent les trajectoires des masses + et ‚àí
                </div>
            </div>

            <div class="equation-card">
                <div class="equation-label">Conservation G√©n√©ralis√©e</div>
                <div class="equation-content">
                    \(\rho c^2 a^3 + \bar{\rho}\bar{c}^2\bar{a}^3 = E = \text{cte}\)
                </div>
                <div class="equation-desc">
                    L'√©nergie totale \(E < 0\) explique l'acc√©l√©ration de l'expansion cosmique
                </div>
            </div>
        </div>

        <!-- Interaction Laws -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">Lois d'Interaction</div>
                <div class="section-badge">Approx. Newtonienne</div>
            </div>

            <div class="laws-container">
                <div class="law-card">
                    <div class="law-visual">
                        <div class="particle pos"></div>
                        <span style="color: var(--dim)">+</span>
                        <div class="particle pos"></div>
                    </div>
                    <div class="law-arrow attract">‚ü∂</div>
                    <div class="law-info">
                        <div class="law-name">Attraction mutuelle</div>
                        <div class="law-formula">F = +G¬∑m‚ÇÅ¬∑m‚ÇÇ/r¬≤</div>
                    </div>
                </div>

                <div class="law-card">
                    <div class="law-visual">
                        <div class="particle neg"></div>
                        <span style="color: var(--dim)">+</span>
                        <div class="particle neg"></div>
                    </div>
                    <div class="law-arrow attract">‚ü∂</div>
                    <div class="law-info">
                        <div class="law-name">Attraction mutuelle</div>
                        <div class="law-formula">F = +G¬∑|m‚ÇÅ|¬∑|m‚ÇÇ|/r¬≤</div>
                    </div>
                </div>

                <div class="law-card">
                    <div class="law-visual">
                        <div class="particle pos"></div>
                        <span style="color: var(--dim)">+</span>
                        <div class="particle neg"></div>
                    </div>
                    <div class="law-arrow repel">‚ü∑</div>
                    <div class="law-info">
                        <div class="law-name">R√©pulsion mutuelle</div>
                        <div class="law-formula">F = ‚àíG¬∑|m‚ÇÅ|¬∑|m‚ÇÇ|/r¬≤</div>
                    </div>
                </div>
            </div>

            <div class="analysis-card" style="margin-top: 12px;">
                <div class="analysis-content">
                    <strong>‚ö†Ô∏è Pas d'effet Runaway :</strong> Contrairement √† la RG standard, les deux masses se repoussent <em>mutuellement</em> (pas de poursuite infinie).
                </div>
            </div>
        </div>

        <!-- Scenarios -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">Sc√©narios Scientifiques</div>
            </div>

            <div class="scenarios-grid">
                <button class="scenario-btn active full" id="scenario-lattice" onclick="loadScenario('lattice')">
                    <span class="icon">üî∑üî∂üî∑üî∂</span>
                    <span class="name">Maillage Janus √âquilibr√©</span>
                    <span class="desc">Structure alternante +/‚àí qui maintient l'√©quilibre cosmique</span>
                </button>

                <button class="scenario-btn" id="scenario-cosmicweb" onclick="loadScenario('cosmicweb')">
                    <span class="icon">üï∏Ô∏è</span>
                    <span class="name">Toile Cosmique</span>
                    <span class="desc">Filaments et vides</span>
                </button>

                <button class="scenario-btn" id="scenario-dipole" onclick="loadScenario('dipole')">
                    <span class="icon">üîÆ</span>
                    <span class="name">Dip√¥le R√©pulseur</span>
                    <span class="desc">Observ√© par JWST</span>
                </button>

                <button class="scenario-btn" id="scenario-galaxy" onclick="loadScenario('galaxy')">
                    <span class="icon">üåÄ</span>
                    <span class="name">Galaxie + Halo</span>
                    <span class="desc">Courbe rotation plate</span>
                </button>

                <button class="scenario-btn" id="scenario-lensing" onclick="loadScenario('lensing')">
                    <span class="icon">üîç</span>
                    <span class="name">Lentille N√©gative</span>
                    <span class="desc">Effet divergent</span>
                </button>

                <button class="scenario-btn" id="scenario-confinement" onclick="loadScenario('confinement')">
                    <span class="icon">‚öõÔ∏è</span>
                    <span class="name">Confinement</span>
                    <span class="desc">Formation galaxies</span>
                </button>

                <button class="scenario-btn" id="scenario-primordial" onclick="loadScenario('primordial')">
                    <span class="icon">üí•</span>
                    <span class="name">Univers Primordial</span>
                    <span class="desc">Big Bang Janus</span>
                </button>

                <button class="scenario-btn" id="scenario-expansion" onclick="loadScenario('expansion')">
                    <span class="icon">üåå</span>
                    <span class="name">Expansion Acc√©l√©r√©e</span>
                    <span class="desc">Sans √©nergie noire</span>
                </button>

                <button class="scenario-btn" id="scenario-cluster" onclick="loadScenario('cluster')">
                    <span class="icon">‚ú®</span>
                    <span class="name">Amas de Galaxies</span>
                    <span class="desc">Structure lacunaire</span>
                </button>

                <button class="scenario-btn" id="scenario-collision" onclick="loadScenario('collision')">
                    <span class="icon">üí´</span>
                    <span class="name">Collision d'Amas</span>
                    <span class="desc">Type Bullet Cluster</span>
                </button>
            </div>
        </div>

        <!-- Controls -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">Param√®tres Physiques</div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <span class="control-label">Constante G</span>
                    <input type="range" id="ctrl-g" min="0.1" max="3" step="0.05" value="1">
                    <span class="control-value" id="g-value">1.00</span>
                </div>

                <div class="control-row">
                    <span class="control-label">Vitesse simulation</span>
                    <input type="range" id="ctrl-speed" min="0.1" max="2" step="0.05" value="0.5">
                    <span class="control-value" id="speed-value">0.50√ó</span>
                </div>

                <div class="control-row">
                    <span class="control-label">Nb particules</span>
                    <input type="range" id="ctrl-particles" min="50" max="600" step="25" value="250">
                    <span class="control-value" id="particles-value">250</span>
                </div>

                <div class="control-row">
                    <span class="control-label">Ratio m‚Å∫/m‚Åª</span>
                    <input type="range" id="ctrl-ratio" min="0.01" max="2" step="0.01" value="0.053">
                    <span class="control-value" id="ratio-value">5:95</span>
                </div>
                
                <div style="display: flex; gap: 6px; margin-bottom: 12px;">
                    <button class="btn" style="flex:1; padding: 8px; font-size: 9px;" onclick="setRatio(0.053)">
                        üéØ Janus<br><span style="color: var(--accent);">5:95</span>
                    </button>
                    <button class="btn" style="flex:1; padding: 8px; font-size: 9px;" onclick="setRatio(0.5)">
                        ‚öñÔ∏è Test<br><span style="color: var(--dim);">33:67</span>
                    </button>
                    <button class="btn" style="flex:1; padding: 8px; font-size: 9px;" onclick="setRatio(1)">
                        üî¨ √âgal<br><span style="color: var(--dim);">50:50</span>
                    </button>
                </div>
                
                <div class="control-row">
                    <span class="control-label">Collisions</span>
                    <button class="btn active" id="btn-collisions" onclick="toggleCollisions()" style="flex: 1;">
                        ‚ö° Activ√©es
                    </button>
                </div>
            </div>

            <div class="btn-grid">
                <button class="btn primary" id="btn-play" onclick="togglePause()">
                    <span id="play-icon">‚è∏</span> Pause
                </button>
                <button class="btn" onclick="resetSimulation()">‚Ü∫ R√©initialiser</button>
            </div>

            <div class="btn-grid" style="margin-top: 8px;">
                <button class="btn" id="btn-trails" onclick="toggleTrails()">‚óå Tra√Æn√©es</button>
                <button class="btn active" id="btn-forces" onclick="toggleForces()">‚Üí Forces</button>
                <button class="btn" id="btn-links" onclick="toggleLinks()">‚ãØ Liens</button>
                <button class="btn" id="btn-field" onclick="toggleField()">‚óé Champ</button>
            </div>
        </div>
    </div>

    <!-- Right Panel -->
    <div class="panel panel-right">
        <div class="header">
            <div class="title">Analyse Physique</div>
            <div class="subtitle">Donn√©es en temps r√©el</div>
        </div>

        <!-- Tabs -->
        <div class="section">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('stats')">Statistiques</button>
                <button class="tab" onclick="switchTab('physics')">Physique</button>
                <button class="tab" onclick="switchTab('predictions')">Pr√©dictions</button>
            </div>

            <!-- Stats Tab -->
            <div class="tab-content active" id="tab-stats">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Masses Positives</div>
                        <div class="stat-value pos" id="stat-pos">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Masses N√©gatives</div>
                        <div class="stat-value neg" id="stat-neg">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Attractions</div>
                        <div class="stat-value attract" id="stat-attract">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">R√©pulsions</div>
                        <div class="stat-value repel" id="stat-repel">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">√ânergie Cin√©tique</div>
                        <div class="stat-value neutral" id="stat-kinetic">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">√ânergie Potentielle</div>
                        <div class="stat-value neutral" id="stat-potential">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">√ânergie Totale E</div>
                        <div class="stat-value accent" id="stat-total-energy">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">S√©paration CoM</div>
                        <div class="stat-value neutral" id="stat-separation">0</div>
                    </div>
                </div>

                <div class="force-balance">
                    <span class="force-label attract" id="attract-pct">50%</span>
                    <div class="force-bar-container">
                        <div class="force-bar-attract" id="bar-attract" style="width: 50%;"></div>
                        <div class="force-bar-repel" id="bar-repel" style="width: 50%;"></div>
                    </div>
                    <span class="force-label repel" id="repel-pct">50%</span>
                </div>
            </div>

            <!-- Physics Tab -->
            <div class="tab-content" id="tab-physics">
                <div class="analysis-card">
                    <div class="analysis-title">üìä √âtat du Syst√®me</div>
                    <div class="analysis-content" id="system-state">
                        Analyse en cours...
                    </div>
                </div>

                <div class="analysis-card">
                    <div class="analysis-title">üî¨ Structure Observ√©e</div>
                    <div class="analysis-content" id="structure-analysis">
                        Analyse en cours...
                    </div>
                </div>

                <div class="analysis-card">
                    <div class="analysis-title">‚öñÔ∏è √âquilibre des Forces</div>
                    <div class="analysis-content" id="force-analysis">
                        Analyse en cours...
                    </div>
                </div>
            </div>

            <!-- Predictions Tab -->
            <div class="tab-content" id="tab-predictions">
                <div class="prediction-item confirmed">
                    <span class="prediction-icon">üåå</span>
                    <div class="prediction-text">
                        <div class="prediction-title">Structure Lacunaire de l'Univers</div>
                        <div class="prediction-desc">Grands vides cosmiques entour√©s de filaments de galaxies</div>
                    </div>
                    <span class="prediction-status confirmed">Confirm√©</span>
                </div>

                <div class="prediction-item confirmed">
                    <span class="prediction-icon">üî≠</span>
                    <div class="prediction-text">
                        <div class="prediction-title">Galaxies Primordiales Matures</div>
                        <div class="prediction-desc">Galaxies form√©es tr√®s t√¥t (z>7) observ√©es par JWST</div>
                    </div>
                    <span class="prediction-status confirmed">Confirm√©</span>
                </div>

                <div class="prediction-item confirmed">
                    <span class="prediction-icon">üí®</span>
                    <div class="prediction-text">
                        <div class="prediction-title">Dip√¥le R√©pulseur</div>
                        <div class="prediction-desc">Grande concentration de masse n√©gative repoussant les galaxies</div>
                    </div>
                    <span class="prediction-status confirmed">Confirm√©</span>
                </div>

                <div class="prediction-item pending">
                    <span class="prediction-icon">üîç</span>
                    <div class="prediction-text">
                        <div class="prediction-title">Lentille Gravitationnelle N√©gative</div>
                        <div class="prediction-desc">Effet divergent autour des vides cosmiques</div>
                    </div>
                    <span class="prediction-status pending">√Ä v√©rifier</span>
                </div>

                <div class="prediction-item pending">
                    <span class="prediction-icon">üëª</span>
                    <div class="prediction-text">
                        <div class="prediction-title">Absence de Mati√®re Noire</div>
                        <div class="prediction-desc">Effets expliqu√©s par masse n√©gative invisible</div>
                    </div>
                    <span class="prediction-status pending">√Ä v√©rifier</span>
                </div>
            </div>
        </div>

        <!-- Current Scenario Explanation -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">Ph√©nom√®ne en Cours</div>
            </div>

            <div class="explanation-card">
                <div class="explanation-header">
                    <div class="explanation-icon" id="explanation-icon">üí°</div>
                    <div class="explanation-title" id="explanation-title">Maillage Janus √âquilibr√©</div>
                </div>
                <div class="explanation-text" id="explanation-text">
                    Chargement...
                </div>
            </div>
        </div>

        <!-- Historical Timeline -->
        <div class="section">
            <div class="section-header">
                <div class="section-title">D√©veloppement du Mod√®le</div>
            </div>

            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">1967</div>
                    <div class="timeline-text">Sakharov propose l'id√©e d'univers jumeaux</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1977</div>
                    <div class="timeline-text">Petit publie les premi√®res √©quations bim√©triques</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">1994</div>
                    <div class="timeline-text">Premi√®res simulations num√©riques</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">2014-15</div>
                    <div class="timeline-text">Formalisation math√©matique compl√®te</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">2017</div>
                    <div class="timeline-text">D√©couverte du Dip√¥le R√©pulseur</div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">2022-24</div>
                    <div class="timeline-text">JWST confirme les galaxies primordiales</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Bar -->
    <div class="info-bar">
        <div class="info-item">
            <div class="info-label">Temps Cosmique</div>
            <div class="info-value" id="cosmic-time">t = 0.0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Particules</div>
            <div class="info-value" id="particle-count">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Interactions/frame</div>
            <div class="info-value" id="interactions">0</div>
        </div>
        <div class="info-item">
            <div class="info-label">Ratio E/K</div>
            <div class="info-value" id="energy-ratio">--</div>
        </div>
        <div class="info-item">
            <div class="info-label">FPS</div>
            <div class="info-value" id="fps">60</div>
        </div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background: var(--pos); box-shadow: 0 0 6px var(--pos);"></div>
            <span>Masse + (mati√®re visible)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: var(--neg); box-shadow: 0 0 6px var(--neg);"></div>
            <span>Masse ‚àí (invisible)</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: var(--attract);"></div>
            <span>Attraction</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: var(--repel);"></div>
            <span>R√©pulsion</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // JANUS COSMOLOGICAL MODEL - SCIENTIFIC SIMULATION
        // Based on J.P. Petit's bimetric theory
        // ============================================

        const CONFIG = {
            G: 1.0,
            SOFTENING: 2.5,
            DT: 0.016,
            SPEED: 0.5,
            DAMPING: 0.998,
            BOUNDS: 180,
            TRAIL_LENGTH: 50,
            MAX_FORCE: 10.0,
            N_PARTICLES: 250,
            MASS_RATIO: 0.053, // 5% visible (m+) / 95% invisible (m-) selon Janus
            MASS_RANGE: [1, 2.5],
            COLLISION_RADIUS: 4.0, // Rayon de collision
            COLLISION_DAMPING: 0.9, // √âlasticit√© des collisions
            ENABLE_COLLISIONS: true
        };

        // Three.js Setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);

        // Add subtle stars
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 2000; i++) {
            starPositions.push(
                (Math.random() - 0.5) * 1000,
                (Math.random() - 0.5) * 1000,
                (Math.random() - 0.5) * 1000
            );
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0x444466, size: 0.5 });
        scene.add(new THREE.Points(starsGeometry, starsMaterial));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 120, 280);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x303040, 0.8));
        const light1 = new THREE.PointLight(0x00b4d8, 0.6, 400);
        light1.position.set(100, 100, 100);
        scene.add(light1);
        const light2 = new THREE.PointLight(0xff6b35, 0.4, 400);
        light2.position.set(-100, -50, -100);
        scene.add(light2);

        // Particle Class
        class Particle {
            constructor(mass, position, velocity) {
                this.mass = mass;
                this.position = position.clone();
                this.velocity = velocity.clone();
                this.force = new THREE.Vector3();
                this.trail = [];
            }
        }

        // State
        let particles = [];
        let particleMeshes = [];
        let trails = [];
        let forceLines = new THREE.Group();
        let linkLines = new THREE.Group();
        let fieldPoints = new THREE.Group();
        scene.add(forceLines);
        scene.add(linkLines);
        scene.add(fieldPoints);

        let isPaused = false;
        let showTrails = false;
        let showForces = true;
        let showLinks = false;
        let showField = false;
        let simTime = 0;
        let frameCount = 0;
        let lastFpsTime = performance.now();

        // Physics counters
        let attractCount = 0, repelCount = 0;
        let totalAttractForce = 0, totalRepelForce = 0;
        let kineticEnergy = 0, potentialEnergy = 0;

        // Scenarios data
        const SCENARIOS = {
            lattice: {
                icon: 'üî∑',
                title: 'Maillage Janus √âquilibr√©',
                text: `<strong>Structure fondamentale du mod√®le Janus</strong><br><br>
                    Les <span class="hl-pos">masses positives (bleu)</span> et <span class="hl-neg">masses n√©gatives (orange)</span> 
                    sont dispos√©es en <strong>alternance r√©guli√®re</strong> dans un r√©seau 3D.<br><br>
                    <strong>Chaque particule subit :</strong><br>
                    ‚Ä¢ <span class="hl-attract">Attraction</span> vers les masses de m√™me signe (diagonales)<br>
                    ‚Ä¢ <span class="hl-repel">R√©pulsion</span> des voisins imm√©diats (signe oppos√©)<br><br>
                    Cet √©quilibre dynamique maintient la <span class="hl-accent">structure √† grande √©chelle de l'univers</span>. 
                    Sans cet arrangement, la mati√®re s'effondrerait ou se disperserait.`
            },
            cosmicweb: {
                icon: 'üï∏Ô∏è',
                title: 'Toile Cosmique',
                text: `<strong>Structure lacunaire de l'univers</strong><br><br>
                    Les <span class="hl-pos">galaxies (m+)</span> forment des <strong>filaments</strong> et des <strong>murs</strong>, 
                    tandis que les <span class="hl-neg">masses n√©gatives (m‚àí)</span> remplissent les <strong>vides cosmiques</strong>.<br><br>
                    <strong>M√©canisme Janus :</strong><br>
                    ‚Ä¢ m+ et m‚àí se <span class="hl-repel">repoussent mutuellement</span><br>
                    ‚Ä¢ m‚àí forme des conglom√©rats dans les vides<br>
                    ‚Ä¢ m+ est confin√©e aux interfaces ‚Üí filaments<br><br>
                    <span class="hl-accent">Confirm√©</span> par les cartographies 3D de l'univers (SDSS, 2dF).`
            },
            dipole: {
                icon: 'üîÆ',
                title: 'Dip√¥le R√©pulseur',
                text: `<strong>Pr√©diction confirm√©e en 2017</strong><br><br>
                    Un grand <span class="hl-neg">conglom√©rat de masse n√©gative</span> au centre 
                    <span class="hl-repel">repousse</span> les <span class="hl-pos">galaxies environnantes</span>.<br><br>
                    <strong>Observations (Hoffman et al., 2017) :</strong><br>
                    ‚Ä¢ Notre groupe local "fuit" une r√©gion de l'espace<br>
                    ‚Ä¢ Cette r√©gion correspond √† un grand vide cosmique<br>
                    ‚Ä¢ Janus pr√©dit que ce vide contient de la masse n√©gative<br><br>
                    <span class="hl-accent">Nature Astronomy</span> a publi√© cette d√©couverte majeure.`
            },
            galaxy: {
                icon: 'üåÄ',
                title: 'Galaxie avec Halo N√©gatif',
                text: `<strong>Explication des courbes de rotation plates</strong><br><br>
                    Une <span class="hl-pos">galaxie spirale</span> est entour√©e d'un <span class="hl-neg">halo de masse n√©gative invisible</span>.<br><br>
                    <strong>Effet du halo n√©gatif :</strong><br>
                    ‚Ä¢ <span class="hl-repel">Confine</span> la galaxie par r√©pulsion<br>
                    ‚Ä¢ Les √©toiles p√©riph√©riques sont "pouss√©es" vers l'int√©rieur<br>
                    ‚Ä¢ R√©sultat : courbe de rotation <strong>plate</strong><br><br>
                    Cette explication <strong>remplace la mati√®re noire</strong> sans introduire de particules hypoth√©tiques.`
            },
            lensing: {
                icon: 'üîç',
                title: 'Lentille Gravitationnelle N√©gative',
                text: `<strong>Pr√©diction unique du mod√®le Janus</strong><br><br>
                    Les <span class="hl-neg">conglom√©rats de masse n√©gative</span> agissent comme des <strong>lentilles divergentes</strong>.<br><br>
                    <strong>Effet pr√©dit :</strong><br>
                    ‚Ä¢ Lumi√®re des galaxies lointaines <strong>d√©vi√©e vers l'ext√©rieur</strong><br>
                    ‚Ä¢ <strong>Diminution</strong> de la luminosit√© apparente<br>
                    ‚Ä¢ Effet visible en "anneau" autour des grands vides<br><br>
                    <span class="hl-accent">√Ä v√©rifier</span> par des observations d√©di√©es autour des vides cosmiques identifi√©s.`
            },
            confinement: {
                icon: '‚öõÔ∏è',
                title: 'Confinement et Formation des Galaxies',
                text: `<strong>Formation acc√©l√©r√©e des premi√®res structures</strong><br><br>
                    Les <span class="hl-neg">masses n√©gatives</span> forment des "murs" qui <span class="hl-repel">compriment</span> 
                    la <span class="hl-pos">mati√®re positive</span>.<br><br>
                    <strong>Cons√©quences :</strong><br>
                    ‚Ä¢ Compression ‚Üí refroidissement radiatif acc√©l√©r√©<br>
                    ‚Ä¢ Instabilit√© gravitationnelle amplifi√©e<br>
                    ‚Ä¢ Formation de galaxies matures en <strong>&lt; 500 millions d'ann√©es</strong><br><br>
                    <span class="hl-accent">Confirm√© par JWST</span> : galaxies √† z>7 d√©j√† structur√©es et massives.`
            },
            primordial: {
                icon: 'üí•',
                title: 'Univers Primordial (Big Bang Janus)',
                text: `<strong>Cr√©ation simultan√©e des deux secteurs</strong><br><br>
                    Au Big Bang, <span class="hl-pos">mati√®re (m+)</span> et <span class="hl-neg">antimati√®re de masse n√©gative (m‚àí)</span> 
                    sont cr√©√©es en quantit√©s √©gales.<br><br>
                    <strong>Sym√©trie CPT :</strong><br>
                    ‚Ä¢ Notre univers : mati√®re, masse positive, temps ‚Üí<br>
                    ‚Ä¢ Secteur jumeau : antimati√®re, masse n√©gative, temps ‚Üê<br><br>
                    R√©sout le <span class="hl-accent">probl√®me de l'asym√©trie mati√®re-antimati√®re</span> : 
                    l'antimati√®re existe, mais dans le secteur n√©gatif invisible.`
            },
            expansion: {
                icon: 'üåå',
                title: 'Expansion Acc√©l√©r√©e',
                text: `<strong>Sans √©nergie noire</strong><br><br>
                    L'<span class="hl-repel">expansion acc√©l√©r√©e</span> de l'univers est expliqu√©e par la 
                    <strong>r√©pulsion mutuelle</strong> entre masses + et ‚àí.<br><br>
                    <strong>√âquation de conservation :</strong><br>
                    œÅc¬≤a¬≥ + œÅÃÑcÃÑ¬≤ƒÅ¬≥ = E = constante<br><br>
                    Avec <span class="hl-accent">E &lt; 0</span> (√©nergie totale n√©gative), 
                    l'univers acc√©l√®re naturellement sans constante cosmologique Œõ.`
            },
            cluster: {
                icon: '‚ú®',
                title: 'Amas de Galaxies et Vides',
                text: `<strong>Structure lacunaire auto-organis√©e</strong><br><br>
                    Plusieurs <span class="hl-pos">amas de galaxies</span> s√©par√©s par des <span class="hl-neg">vides 
                    remplis de masse n√©gative</span>.<br><br>
                    <strong>Observations confirm√©es :</strong><br>
                    ‚Ä¢ Vides cosmiques de 100-300 Mpc de diam√®tre<br>
                    ‚Ä¢ Galaxies concentr√©es sur les "murs" des vides<br>
                    ‚Ä¢ Structure en "bulles de savon"<br><br>
                    Le mod√®le Janus pr√©dit cette structure depuis 1994.`
            },
            collision: {
                icon: 'üí´',
                title: 'Collision d\'Amas (type Bullet Cluster)',
                text: `<strong>Test crucial du mod√®le</strong><br><br>
                    Deux <span class="hl-pos">amas de galaxies</span> entrent en collision, chacun avec son 
                    <span class="hl-neg">halo de masse n√©gative</span>.<br><br>
                    <strong>Diff√©rence avec ŒõCDM :</strong><br>
                    ‚Ä¢ Mati√®re noire standard : suit les galaxies<br>
                    ‚Ä¢ Masse n√©gative Janus : <span class="hl-repel">s√©par√©e par r√©pulsion</span><br><br>
                    Le Bullet Cluster montre une s√©paration mati√®re/effet gravitationnel 
                    compatible avec les deux mod√®les.`
            }
        };

        // ============================================
        // JANUS PHYSICS - EXACT NEWTONIAN APPROXIMATION
        // ============================================

        function computeJanusForces() {
            particles.forEach(p => p.force.set(0, 0, 0));
            
            attractCount = 0;
            repelCount = 0;
            totalAttractForce = 0;
            totalRepelForce = 0;
            potentialEnergy = 0;

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const r = new THREE.Vector3().subVectors(p2.position, p1.position);
                    const dist = Math.max(r.length(), CONFIG.SOFTENING);
                    
                    // JANUS LAWS (Newtonian approximation from bimetric field equations):
                    // Same sign masses: ATTRACTION (standard gravity)
                    // Opposite sign masses: MUTUAL REPULSION (anti-gravity)
                    
                    const m1 = p1.mass;
                    const m2 = p2.mass;
                    const sameSign = (m1 > 0 && m2 > 0) || (m1 < 0 && m2 < 0);
                    const absM1 = Math.abs(m1);
                    const absM2 = Math.abs(m2);
                    
                    // Force magnitude
                    let forceMag = CONFIG.G * absM1 * absM2 / (dist * dist);
                    
                    // Potential energy contribution
                    if (sameSign) {
                        potentialEnergy -= CONFIG.G * absM1 * absM2 / dist; // Attractive: negative PE
                        attractCount++;
                        totalAttractForce += forceMag;
                    } else {
                        forceMag = -forceMag; // Repulsion
                        potentialEnergy += CONFIG.G * absM1 * absM2 / dist; // Repulsive: positive PE
                        repelCount++;
                        totalRepelForce += Math.abs(forceMag);
                    }
                    
                    // Clamp to avoid numerical instability
                    const clampedMag = Math.sign(forceMag) * Math.min(Math.abs(forceMag), CONFIG.MAX_FORCE);
                    
                    // Apply force along direction vector
                    const forceVec = r.clone().normalize().multiplyScalar(clampedMag);
                    
                    // Newton's 3rd law: equal and opposite
                    p1.force.add(forceVec);
                    p2.force.sub(forceVec);
                }
            }
        }

        function integrateMotion() {
            const dt = CONFIG.DT * CONFIG.SPEED;
            kineticEnergy = 0;
            
            // D'abord, mettre √† jour les positions et vitesses
            particles.forEach(p => {
                // a = F / |m| (inertial mass always positive in Janus)
                const accel = p.force.clone().divideScalar(Math.abs(p.mass));
                
                // Velocity Verlet integration
                p.velocity.add(accel.multiplyScalar(dt));
                p.velocity.multiplyScalar(CONFIG.DAMPING);
                p.position.add(p.velocity.clone().multiplyScalar(dt));
                
                // Kinetic energy
                kineticEnergy += 0.5 * Math.abs(p.mass) * p.velocity.lengthSq();
                
                // Soft boundary (reflective)
                const dist = p.position.length();
                if (dist > CONFIG.BOUNDS) {
                    p.position.multiplyScalar(CONFIG.BOUNDS / dist);
                    p.velocity.multiplyScalar(0.85);
                }
            });
            
            // Ensuite, g√©rer les collisions
            if (CONFIG.ENABLE_COLLISIONS) {
                handleCollisions();
            }
            
            // Trail recording
            particles.forEach(p => {
                if (showTrails) {
                    p.trail.push(p.position.clone());
                    if (p.trail.length > CONFIG.TRAIL_LENGTH) p.trail.shift();
                }
            });
        }
        
        // Collision handling - elastic collision between particles
        function handleCollisions() {
            const collisionRadius = CONFIG.COLLISION_RADIUS;
            const minDist = collisionRadius * 2;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const delta = new THREE.Vector3().subVectors(p2.position, p1.position);
                    const dist = delta.length();
                    
                    // Check for collision
                    if (dist < minDist && dist > 0.01) {
                        // Normal de collision
                        const normal = delta.clone().normalize();
                        
                        // S√©parer les particules (√©viter qu'elles s'imbriquent)
                        const overlap = minDist - dist;
                        const separation = normal.clone().multiplyScalar(overlap * 0.5);
                        p1.position.sub(separation);
                        p2.position.add(separation);
                        
                        // Vitesses relatives
                        const relVel = new THREE.Vector3().subVectors(p1.velocity, p2.velocity);
                        const relVelNormal = relVel.dot(normal);
                        
                        // Ne traiter que si les particules se rapprochent
                        if (relVelNormal > 0) {
                            // Masses (absolues pour l'inertie)
                            const m1 = Math.abs(p1.mass);
                            const m2 = Math.abs(p2.mass);
                            
                            // Coefficient de restitution (√©lasticit√©)
                            const restitution = CONFIG.COLLISION_DAMPING;
                            
                            // Calcul de l'impulsion (collision √©lastique)
                            const impulse = (2 * relVelNormal) / (m1 + m2);
                            
                            // Appliquer l'impulsion
                            const impulseVec1 = normal.clone().multiplyScalar(impulse * m2 * restitution);
                            const impulseVec2 = normal.clone().multiplyScalar(impulse * m1 * restitution);
                            
                            p1.velocity.sub(impulseVec1);
                            p2.velocity.add(impulseVec2);
                            
                            // Ajouter une l√©g√®re composante tangentielle pour cr√©er de la rotation
                            const tangent = new THREE.Vector3(-normal.y, normal.x, normal.z).normalize();
                            const spinFactor = 0.1;
                            p1.velocity.add(tangent.clone().multiplyScalar(relVelNormal * spinFactor));
                            p2.velocity.sub(tangent.clone().multiplyScalar(relVelNormal * spinFactor));
                        }
                    }
                }
            }
        }

        // ============================================
        // VISUALIZATION
        // ============================================

        function updateVisuals() {
            particles.forEach((p, i) => {
                particleMeshes[i].position.copy(p.position);
                
                // Pulsing effect based on force magnitude
                const forceMag = p.force.length();
                const scale = 1 + Math.min(forceMag * 0.05, 0.3);
                particleMeshes[i].scale.setScalar(scale);
                
                // Trail update
                if (showTrails && p.trail.length > 1) {
                    const positions = new Float32Array(p.trail.length * 3);
                    p.trail.forEach((pos, j) => {
                        positions[j * 3] = pos.x;
                        positions[j * 3 + 1] = pos.y;
                        positions[j * 3 + 2] = pos.z;
                    });
                    trails[i].geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    trails[i].geometry.computeBoundingSphere();
                }
                trails[i].visible = showTrails;
            });
            
            if (showForces) updateForceVectors();
            if (showLinks) updateLinkLines();
            if (showField) updateField();
        }

        function updateForceVectors() {
            forceLines.clear();
            
            particles.forEach(p => {
                const forceMag = p.force.length();
                if (forceMag < 0.02) return;
                
                const dir = p.force.clone().normalize();
                const len = Math.min(forceMag * 5, 25);
                
                // Color based on net force direction relative to nearest opposite-sign particle
                let color = 0x00ff88;
                let nearestOpposite = null;
                let minDist = Infinity;
                
                for (const other of particles) {
                    if (other === p) continue;
                    if ((p.mass > 0) === (other.mass > 0)) continue;
                    const d = p.position.distanceTo(other.position);
                    if (d < minDist) {
                        minDist = d;
                        nearestOpposite = other;
                    }
                }
                
                if (nearestOpposite) {
                    const toOpposite = new THREE.Vector3().subVectors(nearestOpposite.position, p.position).normalize();
                    color = p.force.clone().normalize().dot(toOpposite) < 0 ? 0xff2e63 : 0x06ffa5;
                }
                
                const points = [
                    p.position.clone(),
                    p.position.clone().add(dir.multiplyScalar(len))
                ];
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8 });
                forceLines.add(new THREE.Line(geometry, material));
                
                // Arrow head
                const arrowLen = Math.min(len * 0.3, 4);
                const arrowPos = p.position.clone().add(p.force.clone().normalize().multiplyScalar(len));
                const perpendicular = new THREE.Vector3(dir.y - dir.z, dir.z - dir.x, dir.x - dir.y).normalize();
                
                const arrow1 = [
                    arrowPos.clone(),
                    arrowPos.clone().sub(dir.clone().multiplyScalar(arrowLen)).add(perpendicular.clone().multiplyScalar(arrowLen * 0.4))
                ];
                const arrow2 = [
                    arrowPos.clone(),
                    arrowPos.clone().sub(dir.clone().multiplyScalar(arrowLen)).sub(perpendicular.clone().multiplyScalar(arrowLen * 0.4))
                ];
                
                forceLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(arrow1), material.clone()));
                forceLines.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(arrow2), material.clone()));
            });
        }

        function updateLinkLines() {
            linkLines.clear();
            const maxDist = 45;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const dist = p1.position.distanceTo(p2.position);
                    if (dist > maxDist) continue;
                    
                    const sameSign = (p1.mass > 0) === (p2.mass > 0);
                    const opacity = 0.4 * (1 - dist / maxDist);
                    const color = sameSign ? 0x06ffa5 : 0xff2e63;
                    
                    const points = [p1.position.clone(), p2.position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
                    linkLines.add(new THREE.Line(geometry, material));
                }
            }
        }

        function updateField() {
            fieldPoints.clear();
            
            const gridSize = 8;
            const spacing = CONFIG.BOUNDS * 1.5 / gridSize;
            
            for (let x = -gridSize/2; x <= gridSize/2; x++) {
                for (let y = -gridSize/2; y <= gridSize/2; y++) {
                    for (let z = -gridSize/2; z <= gridSize/2; z++) {
                        const pos = new THREE.Vector3(x * spacing, y * spacing, z * spacing);
                        
                        // Calculate field at this point
                        let fieldStrength = 0;
                        particles.forEach(p => {
                            const r = pos.distanceTo(p.position);
                            if (r < 3) return;
                            fieldStrength += p.mass / (r * r);
                        });
                        
                        const size = Math.min(Math.abs(fieldStrength) * 0.5, 2);
                        if (size < 0.3) continue;
                        
                        const color = fieldStrength > 0 ? 0x00b4d8 : 0xff6b35;
                        const geometry = new THREE.SphereGeometry(size, 6, 6);
                        const material = new THREE.MeshBasicMaterial({ 
                            color, 
                            transparent: true, 
                            opacity: 0.3 
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(pos);
                        fieldPoints.add(mesh);
                    }
                }
            }
        }

        // ============================================
        // STATISTICS & ANALYSIS
        // ============================================

        function updateStatistics() {
            const posParticles = particles.filter(p => p.mass > 0);
            const negParticles = particles.filter(p => p.mass < 0);
            
            document.getElementById('stat-pos').textContent = posParticles.length;
            document.getElementById('stat-neg').textContent = negParticles.length;
            document.getElementById('stat-attract').textContent = attractCount;
            document.getElementById('stat-repel').textContent = repelCount;
            document.getElementById('stat-kinetic').textContent = kineticEnergy.toFixed(1);
            document.getElementById('stat-potential').textContent = potentialEnergy.toFixed(1);
            
            const totalEnergy = kineticEnergy + potentialEnergy;
            document.getElementById('stat-total-energy').textContent = totalEnergy.toFixed(1);
            
            // Separation
            if (posParticles.length > 0 && negParticles.length > 0) {
                const comPos = new THREE.Vector3();
                const comNeg = new THREE.Vector3();
                let mPos = 0, mNeg = 0;
                
                posParticles.forEach(p => {
                    comPos.add(p.position.clone().multiplyScalar(p.mass));
                    mPos += p.mass;
                });
                comPos.divideScalar(mPos);
                
                negParticles.forEach(p => {
                    comNeg.add(p.position.clone().multiplyScalar(Math.abs(p.mass)));
                    mNeg += Math.abs(p.mass);
                });
                comNeg.divideScalar(mNeg);
                
                document.getElementById('stat-separation').textContent = comPos.distanceTo(comNeg).toFixed(1);
            }
            
            // Force balance bar
            const total = totalAttractForce + totalRepelForce;
            if (total > 0) {
                const attractPct = (totalAttractForce / total * 100).toFixed(0);
                const repelPct = (totalRepelForce / total * 100).toFixed(0);
                document.getElementById('attract-pct').textContent = attractPct + '%';
                document.getElementById('repel-pct').textContent = repelPct + '%';
                document.getElementById('bar-attract').style.width = attractPct + '%';
                document.getElementById('bar-repel').style.width = repelPct + '%';
            }
            
            // Info bar
            document.getElementById('cosmic-time').textContent = `t = ${simTime.toFixed(1)}`;
            document.getElementById('particle-count').textContent = particles.length;
            document.getElementById('interactions').textContent = attractCount + repelCount;
            
            const energyRatio = kineticEnergy > 0 ? (potentialEnergy / kineticEnergy).toFixed(2) : '--';
            document.getElementById('energy-ratio').textContent = energyRatio;
            
            // FPS
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime > 1000) {
                document.getElementById('fps').textContent = Math.round(frameCount * 1000 / (now - lastFpsTime));
                frameCount = 0;
                lastFpsTime = now;
            }
            
            // Physics analysis (throttled)
            if (Math.floor(simTime * 10) % 5 === 0) {
                updatePhysicsAnalysis(posParticles, negParticles, totalEnergy);
            }
        }

        function updatePhysicsAnalysis(posParticles, negParticles, totalEnergy) {
            // System state
            let stateHTML = '';
            const avgVelPos = posParticles.length > 0 ? 
                posParticles.reduce((s, p) => s + p.velocity.length(), 0) / posParticles.length : 0;
            const avgVelNeg = negParticles.length > 0 ? 
                negParticles.reduce((s, p) => s + p.velocity.length(), 0) / negParticles.length : 0;
            
            if (avgVelPos < 0.3 && avgVelNeg < 0.3) {
                stateHTML = '<span class="hl-accent">√âtat quasi-stationnaire</span> ‚Äî Les particules atteignent un √©quilibre dynamique.';
            } else if (avgVelPos > avgVelNeg * 1.5) {
                stateHTML = '<span class="hl-pos">Masses + agit√©es</span> ‚Äî R√©pulsion dominante des masses ‚àí.';
            } else if (avgVelNeg > avgVelPos * 1.5) {
                stateHTML = '<span class="hl-neg">Masses ‚àí agit√©es</span> ‚Äî Migration vers les r√©gions de vide.';
            } else {
                stateHTML = '<span class="hl-accent">√âvolution active</span> ‚Äî Structure en formation.';
            }
            document.getElementById('system-state').innerHTML = stateHTML;
            
            // Structure analysis
            let structHTML = '';
            const avgRadPos = posParticles.length > 0 ? 
                posParticles.reduce((s, p) => s + p.position.length(), 0) / posParticles.length : 0;
            const avgRadNeg = negParticles.length > 0 ? 
                negParticles.reduce((s, p) => s + p.position.length(), 0) / negParticles.length : 0;
            
            if (avgRadNeg > avgRadPos * 1.3) {
                structHTML = '<span class="hl-neg">Masses ‚àí en p√©riph√©rie</span> ‚Äî Formation d\'un halo n√©gatif typique.';
            } else if (avgRadPos > avgRadNeg * 1.3) {
                structHTML = '<span class="hl-pos">Masses + dispers√©es</span> ‚Äî Effet de r√©pulsion du noyau n√©gatif.';
            } else {
                structHTML = '<span class="hl-accent">Distribution mixte</span> ‚Äî Structure lacunaire en formation.';
            }
            document.getElementById('structure-analysis').innerHTML = structHTML;
            
            // Force analysis
            let forceHTML = '';
            const ratio = totalRepelForce > 0 ? totalAttractForce / totalRepelForce : Infinity;
            
            if (ratio > 0.9 && ratio < 1.1) {
                forceHTML = '<span class="hl-accent">√âquilibre Janus</span> ‚Äî Attractions et r√©pulsions se compensent ‚Üí structure stable.';
            } else if (ratio > 1.1) {
                forceHTML = '<span class="hl-attract">Attraction dominante</span> ‚Äî Tendance au regroupement par type de masse.';
            } else {
                forceHTML = '<span class="hl-repel">R√©pulsion dominante</span> ‚Äî Expansion et s√©gr√©gation des populations.';
            }
            
            if (totalEnergy < 0) {
                forceHTML += '<br><br><span class="hl-neg">E < 0</span> ‚Äî Syst√®me li√© (conforme √† la pr√©diction Janus pour l\'univers).';
            }
            document.getElementById('force-analysis').innerHTML = forceHTML;
        }

        // ============================================
        // SCENARIOS
        // ============================================

        function clearScene() {
            particles = [];
            particleMeshes.forEach(m => scene.remove(m));
            particleMeshes = [];
            trails.forEach(t => scene.remove(t));
            trails = [];
            forceLines.clear();
            linkLines.clear();
            fieldPoints.clear();
            simTime = 0;
        }

        function addParticle(mass, pos, vel) {
            const p = new Particle(mass, pos, vel);
            particles.push(p);
            
            const isPositive = mass > 0;
            const baseColor = isPositive ? 0x00b4d8 : 0xff6b35;
            const size = Math.cbrt(Math.abs(mass)) * 1.8;
            
            const geometry = new THREE.SphereGeometry(size, 20, 20);
            const material = new THREE.MeshStandardMaterial({
                color: baseColor,
                emissive: baseColor,
                emissiveIntensity: 0.6,
                metalness: 0.3,
                roughness: 0.5,
                transparent: true,
                opacity: 0.95
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            scene.add(mesh);
            particleMeshes.push(mesh);
            
            // Trail
            const trailGeom = new THREE.BufferGeometry();
            const trailMat = new THREE.LineBasicMaterial({ 
                color: baseColor, 
                transparent: true, 
                opacity: 0.4 
            });
            const trail = new THREE.Line(trailGeom, trailMat);
            trail.visible = false;
            scene.add(trail);
            trails.push(trail);
        }

        function loadScenario(name) {
            clearScene();
            
            // Update UI
            document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`scenario-${name}`)?.classList.add('active');
            
            const scenario = SCENARIOS[name];
            if (scenario) {
                document.getElementById('explanation-icon').textContent = scenario.icon;
                document.getElementById('explanation-title').textContent = scenario.title;
                document.getElementById('explanation-text').innerHTML = scenario.text;
            }
            
            // Create particles based on scenario
            switch(name) {
                case 'lattice': createLattice(); break;
                case 'cosmicweb': createCosmicWeb(); break;
                case 'dipole': createDipole(); break;
                case 'galaxy': createGalaxy(); break;
                case 'lensing': createLensing(); break;
                case 'confinement': createConfinement(); break;
                case 'primordial': createPrimordial(); break;
                case 'expansion': createExpansion(); break;
                case 'cluster': createCluster(); break;
                case 'collision': createCollision(); break;
            }
        }

        // ============================================
        // SCENARIO CREATORS
        // ============================================

        function createLattice() {
            // Alternating 3D lattice: +‚àí+‚àí+‚àí...
            // Le ratio contr√¥le la probabilit√© d'avoir une masse + vs -
            const spacing = 22;
            const gridSize = 5;
            const offset = (gridSize - 1) * spacing / 2;
            
            // Ratio = 1 ‚Üí 50/50, Ratio = 2 ‚Üí 66/33 (+/-), Ratio = 0.5 ‚Üí 33/66
            const probPositive = CONFIG.MASS_RATIO / (CONFIG.MASS_RATIO + 1);
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        // Alternance de base, mais modul√©e par le ratio
                        const basePositive = (x + y + z) % 2 === 0;
                        // On garde l'alternance mais on peut "flipper" certaines particules selon le ratio
                        let isPositive;
                        if (CONFIG.MASS_RATIO === 1) {
                            isPositive = basePositive;
                        } else if (CONFIG.MASS_RATIO > 1) {
                            // Plus de positives : les n√©gatives ont une chance de devenir positives
                            isPositive = basePositive || (Math.random() < (CONFIG.MASS_RATIO - 1) / CONFIG.MASS_RATIO);
                        } else {
                            // Plus de n√©gatives : les positives ont une chance de devenir n√©gatives
                            isPositive = basePositive && (Math.random() < CONFIG.MASS_RATIO);
                        }
                        
                        const mass = isPositive ? 
                            CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]) :
                            -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                        
                        const pos = new THREE.Vector3(
                            x * spacing - offset + (Math.random() - 0.5) * 3,
                            y * spacing - offset + (Math.random() - 0.5) * 3,
                            z * spacing - offset + (Math.random() - 0.5) * 3
                        );
                        
                        const vel = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15);
                        addParticle(mass, pos, vel);
                    }
                }
            }
        }

        function createCosmicWeb() {
            // Le ratio ajuste la proportion pos/neg
            const totalN = CONFIG.N_PARTICLES;
            const nPos = Math.floor(totalN * CONFIG.MASS_RATIO / (CONFIG.MASS_RATIO + 1));
            const nNeg = totalN - nPos;
            
            // Filaments of positive mass
            const filaments = 5;
            for (let f = 0; f < filaments; f++) {
                const angle = (f / filaments) * Math.PI * 2;
                
                for (let i = 0; i < nPos / filaments; i++) {
                    const t = (i / (nPos / filaments) - 0.5) * 140;
                    const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                    
                    const pos = new THREE.Vector3(
                        t * Math.cos(angle) + (Math.random() - 0.5) * 18,
                        (Math.random() - 0.5) * 18,
                        t * Math.sin(angle) + (Math.random() - 0.5) * 18
                    );
                    
                    addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.25));
                }
            }
            
            // Negative mass in voids
            for (let i = 0; i < nNeg; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const voidAngle = (Math.floor(Math.random() * filaments) + 0.5) * (Math.PI * 2 / filaments);
                const r = 25 + Math.random() * 45;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(voidAngle) + (Math.random() - 0.5) * 35,
                    (Math.random() - 0.5) * 50,
                    r * Math.sin(voidAngle) + (Math.random() - 0.5) * 35
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.2));
            }
        }

        function createDipole() {
            const n = CONFIG.N_PARTICLES;
            
            // Large negative mass concentration at center (Dipole Repeller)
            for (let i = 0; i < n * 0.4; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0])) * 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 30;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.1));
            }
            
            // Positive masses being repelled outward
            for (let i = 0; i < n * 0.5; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 55 + Math.random() * 50;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Slight inward velocity - will be repelled
                const vel = pos.clone().normalize().multiplyScalar(-0.3);
                addParticle(mass, pos, vel);
            }
            
            // Some negative in outer regions
            for (let i = 0; i < n * 0.1; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 110 + Math.random() * 30;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.1));
            }
        }

        function createGalaxy() {
            // Utiliser le ratio pour d√©finir les proportions
            const totalN = CONFIG.N_PARTICLES;
            const nPos = Math.max(10, Math.floor(totalN * CONFIG.MASS_RATIO / (CONFIG.MASS_RATIO + 1)));
            const nNeg = totalN - nPos;
            
            // Spiral galaxy (masses positives en rotation)
            for (let i = 0; i < nPos; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const arm = i % 2;
                const t = (i / nPos) * 3.5 * Math.PI;
                const r = 8 + t * 5;
                const theta = t + arm * Math.PI + (Math.random() - 0.5) * 0.5;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(theta) + (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 4,
                    r * Math.sin(theta) + (Math.random() - 0.5) * 5
                );
                
                // Vitesse orbitale: v = sqrt(G * M_central / r)
                // Dans Janus, le halo n√©gatif contribue √† confiner, donc on augmente la vitesse
                const orbitalSpeed = Math.sqrt(CONFIG.G * 40 / Math.max(r, 8)) * 0.8;
                // Vitesse perpendiculaire au rayon (rotation)
                const vel = new THREE.Vector3(
                    -orbitalSpeed * Math.sin(theta),
                    (Math.random() - 0.5) * 0.1,
                    orbitalSpeed * Math.cos(theta)
                );
                addParticle(mass, pos, vel);
            }
            
            // Negative mass halo (confinement)
            for (let i = 0; i < nNeg; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 50 + Math.random() * 45;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) * 0.5, // Halo aplati
                    r * Math.cos(phi)
                );
                
                // L√©g√®re rotation du halo aussi
                const haloSpeed = 0.15;
                const vel = new THREE.Vector3(
                    -haloSpeed * Math.sin(theta),
                    0,
                    haloSpeed * Math.cos(theta)
                );
                addParticle(mass, pos, vel);
            }
        }

        function createLensing() {
            const n = CONFIG.N_PARTICLES;
            
            // Central negative mass (lensing mass)
            for (let i = 0; i < n * 0.35; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0])) * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 25;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.08));
            }
            
            // Background galaxies (positive) - will be "lensed"
            for (let i = 0; i < n * 0.5; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const theta = Math.random() * Math.PI * 2;
                const r = 60 + Math.random() * 70;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(theta) + (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 80 - 50, // Behind the lens
                    r * Math.sin(theta) + (Math.random() - 0.5) * 20
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15));
            }
            
            // Observer-side positive masses
            for (let i = 0; i < n * 0.15; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * 60,
                    50 + Math.random() * 30,
                    (Math.random() - 0.5) * 60
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15));
            }
        }

        function createConfinement() {
            const n = CONFIG.N_PARTICLES;
            
            // Positive mass cloud
            for (let i = 0; i < n * 0.4; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 40;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.3));
            }
            
            // Negative mass shell (confinement)
            for (let i = 0; i < n * 0.6; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 60 + Math.random() * 25;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                // Inward velocity
                const vel = pos.clone().normalize().multiplyScalar(-0.4);
                addParticle(mass, pos, vel);
            }
        }

        function createPrimordial() {
            const n = CONFIG.N_PARTICLES;
            
            // Equal amounts of + and - starting from near-singularity
            for (let i = 0; i < n / 2; i++) {
                // Positive mass
                const massPos = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const thetaPos = Math.random() * Math.PI * 2;
                const phiPos = Math.acos(2 * Math.random() - 1);
                const rPos = 5 + Math.random() * 25;
                
                const posPos = new THREE.Vector3(
                    rPos * Math.sin(phiPos) * Math.cos(thetaPos),
                    rPos * Math.sin(phiPos) * Math.sin(thetaPos),
                    rPos * Math.cos(phiPos)
                );
                
                // Outward expansion velocity
                const velPos = posPos.clone().normalize().multiplyScalar(0.8 + Math.random() * 0.5);
                addParticle(massPos, posPos, velPos);
                
                // Negative mass (roughly opposite direction for CPT symmetry visualization)
                const massNeg = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const posNeg = new THREE.Vector3(
                    -posPos.x + (Math.random() - 0.5) * 10,
                    -posPos.y + (Math.random() - 0.5) * 10,
                    -posPos.z + (Math.random() - 0.5) * 10
                );
                
                const velNeg = posNeg.clone().normalize().multiplyScalar(0.8 + Math.random() * 0.5);
                addParticle(massNeg, posNeg, velNeg);
            }
        }

        function createExpansion() {
            const n = CONFIG.N_PARTICLES;
            // Le ratio contr√¥le la probabilit√© d'√™tre positif
            const probPositive = CONFIG.MASS_RATIO / (CONFIG.MASS_RATIO + 1);
            
            // Uniform mix
            for (let i = 0; i < n; i++) {
                const isPositive = Math.random() < probPositive;
                const mass = isPositive ?
                    CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]) :
                    -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 70;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.25));
            }
        }

        function createCluster() {
            const n = Math.floor(CONFIG.N_PARTICLES / 5);
            
            // Multiple clusters
            const centers = [
                new THREE.Vector3(-55, 35, 0),
                new THREE.Vector3(55, 35, 0),
                new THREE.Vector3(0, -35, -50),
                new THREE.Vector3(0, -35, 50)
            ];
            
            centers.forEach(center => {
                for (let i = 0; i < n; i++) {
                    const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                    const offset = new THREE.Vector3().random().subScalar(0.5).multiplyScalar(35);
                    addParticle(mass, center.clone().add(offset), new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.25));
                }
            });
            
            // Negative in voids
            for (let i = 0; i < n * 2; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * 35;
                
                const pos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                
                addParticle(mass, pos, new THREE.Vector3().random().subScalar(0.5).multiplyScalar(0.15));
            }
        }

        function createCollision() {
            const n = Math.floor(CONFIG.N_PARTICLES / 4);
            
            // Left cluster + halo
            for (let i = 0; i < n; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    -65 + (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                addParticle(mass, pos, new THREE.Vector3(1.8, 0, 0));
            }
            
            for (let i = 0; i < n * 0.5; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 30 + Math.random() * 15;
                const pos = new THREE.Vector3(
                    -65 + r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                addParticle(mass, pos, new THREE.Vector3(1.8, 0, 0));
            }
            
            // Right cluster + halo
            for (let i = 0; i < n; i++) {
                const mass = CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]);
                const pos = new THREE.Vector3(
                    65 + (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                addParticle(mass, pos, new THREE.Vector3(-1.8, 0, 0));
            }
            
            for (let i = 0; i < n * 0.5; i++) {
                const mass = -(CONFIG.MASS_RANGE[0] + Math.random() * (CONFIG.MASS_RANGE[1] - CONFIG.MASS_RANGE[0]));
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 30 + Math.random() * 15;
                const pos = new THREE.Vector3(
                    65 + r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                addParticle(mass, pos, new THREE.Vector3(-1.8, 0, 0));
            }
        }

        // ============================================
        // CAMERA CONTROLS
        // ============================================

        let cameraTheta = Math.PI / 4;
        let cameraPhi = Math.PI / 3;
        let cameraRadius = 280;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        function updateCamera() {
            camera.position.x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            camera.position.y = cameraRadius * Math.cos(cameraPhi);
            camera.position.z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            camera.lookAt(0, 0, 0);
        }

        renderer.domElement.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
            if (!isDragging) return;
            cameraTheta -= (e.clientX - lastMouse.x) * 0.005;
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + (e.clientY - lastMouse.y) * 0.005));
            lastMouse = { x: e.clientX, y: e.clientY };
            updateCamera();
        });

        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mouseleave', () => isDragging = false);
        renderer.domElement.addEventListener('wheel', e => {
            cameraRadius = Math.max(80, Math.min(500, cameraRadius + e.deltaY * 0.5));
            updateCamera();
        });

        // ============================================
        // UI CONTROLS
        // ============================================

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('btn-play').innerHTML = isPaused ? '<span>‚ñ∂</span> Play' : '<span>‚è∏</span> Pause';
            document.getElementById('btn-play').classList.toggle('active', !isPaused);
        }

        function toggleTrails() {
            showTrails = !showTrails;
            document.getElementById('btn-trails').classList.toggle('active', showTrails);
            if (!showTrails) particles.forEach(p => p.trail = []);
        }

        function toggleForces() {
            showForces = !showForces;
            document.getElementById('btn-forces').classList.toggle('active', showForces);
            if (!showForces) forceLines.clear();
        }

        function toggleLinks() {
            showLinks = !showLinks;
            document.getElementById('btn-links').classList.toggle('active', showLinks);
            if (!showLinks) linkLines.clear();
        }

        function toggleField() {
            showField = !showField;
            document.getElementById('btn-field').classList.toggle('active', showField);
            if (!showField) fieldPoints.clear();
        }
        
        function toggleCollisions() {
            CONFIG.ENABLE_COLLISIONS = !CONFIG.ENABLE_COLLISIONS;
            document.getElementById('btn-collisions').classList.toggle('active', CONFIG.ENABLE_COLLISIONS);
            document.getElementById('btn-collisions').innerHTML = CONFIG.ENABLE_COLLISIONS ? '‚ö° Activ√©es' : '‚óã D√©sactiv√©es';
        }
        
        function setRatio(ratio) {
            CONFIG.MASS_RATIO = ratio;
            document.getElementById('ctrl-ratio').value = ratio;
            updateRatioDisplay(ratio);
            // Recharger le sc√©nario actif
            const active = document.querySelector('.scenario-btn.active');
            if (active) {
                loadScenario(active.id.replace('scenario-', ''));
            }
        }
        
        function updateRatioDisplay(ratio) {
            const pctPos = Math.round(ratio / (ratio + 1) * 100);
            const pctNeg = 100 - pctPos;
            document.getElementById('ratio-value').textContent = `${pctPos}:${pctNeg}`;
        }

        function resetSimulation() {
            const active = document.querySelector('.scenario-btn.active');
            if (active) {
                loadScenario(active.id.replace('scenario-', ''));
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }

        // Sliders
        document.getElementById('ctrl-g').addEventListener('input', function() {
            CONFIG.G = parseFloat(this.value);
            document.getElementById('g-value').textContent = CONFIG.G.toFixed(2);
        });

        document.getElementById('ctrl-speed').addEventListener('input', function() {
            CONFIG.SPEED = parseFloat(this.value);
            document.getElementById('speed-value').textContent = CONFIG.SPEED.toFixed(2) + '√ó';
        });

        document.getElementById('ctrl-particles').addEventListener('input', function() {
            CONFIG.N_PARTICLES = parseInt(this.value);
            document.getElementById('particles-value').textContent = CONFIG.N_PARTICLES;
        });

        document.getElementById('ctrl-ratio').addEventListener('input', function() {
            CONFIG.MASS_RATIO = parseFloat(this.value);
            updateRatioDisplay(CONFIG.MASS_RATIO);
        });
        
        // Quand on rel√¢che le slider, recharger le sc√©nario
        document.getElementById('ctrl-ratio').addEventListener('change', function() {
            const active = document.querySelector('.scenario-btn.active');
            if (active) {
                loadScenario(active.id.replace('scenario-', ''));
            }
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused && particles.length > 0) {
                computeJanusForces();
                integrateMotion();
                updateVisuals();
                updateStatistics();
                simTime += CONFIG.DT * CONFIG.SPEED;
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        updateCamera();
        updateRatioDisplay(CONFIG.MASS_RATIO); // Afficher le ratio initial (5:95)
        loadScenario('lattice');
        animate();
        
        // Render MathJax equations
        if (window.MathJax) {
            MathJax.typeset();
        }
    </script>
</body>
</html>
