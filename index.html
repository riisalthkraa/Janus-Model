<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JANUS v5.1 ‚Äî Simulation Cosmologique (Calibr√© pour Gravit√©=1.0)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #020306;
            --panel: rgba(6, 10, 20, 0.96);
            --card: rgba(12, 20, 36, 0.9);
            --border: rgba(0, 200, 255, 0.12);
            --text: #e4ecf4;
            --dim: #5a7090;
            --accent: #00d4ff;
            --positive: #00ff88;
            --negative: #ff5544;
            --ocean: #6040ff;
            --void: #200840;
            --blackhole: #ff00ff;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas { position: fixed; inset: 0; z-index: 1; }
        
        /* Panels */
        .panel {
            position: fixed;
            top: 0;
            height: 100vh;
            background: var(--panel);
            backdrop-filter: blur(20px);
            z-index: 100;
            overflow-y: auto;
            border: 1px solid var(--border);
            padding: 16px;
        }
        
        .panel::-webkit-scrollbar { width: 4px; }
        .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
        
        .panel-left { left: 0; width: 300px; }
        .panel-right { right: 0; width: 320px; }
        
        h1 {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent), var(--positive));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle { font-size: 9px; color: var(--dim); margin-bottom: 16px; letter-spacing: 0.5px; }
        
        .section { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border); }
        .section-title { font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; color: var(--dim); margin-bottom: 10px; }
        
        /* Cards */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 10px;
        }
        
        .card.highlight { background: linear-gradient(135deg, rgba(0,212,255,0.1), rgba(0,255,136,0.05)); border-color: rgba(0,212,255,0.3); }
        .card.desi { background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.05)); border-color: rgba(255,150,0,0.3); }
        .card.janus { background: linear-gradient(135deg, rgba(96,64,255,0.1), rgba(0,212,255,0.05)); border-color: rgba(96,64,255,0.3); }
        
        .card-title { font-weight: 600; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
        .note { color: var(--dim); line-height: 1.5; font-size: 9px; }
        
        .eq {
            font-family: monospace;
            font-size: 11px;
            color: var(--accent);
            background: rgba(0,0,0,0.3);
            padding: 5px 8px;
            border-radius: 4px;
            margin: 6px 0;
            border-left: 2px solid var(--accent);
        }
        
        /* Mode tabs */
        .mode-tabs { display: flex; gap: 3px; margin-bottom: 12px; }
        
        .mode-tab {
            flex: 1;
            padding: 8px 4px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--dim);
            font-size: 9px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .mode-tab:hover { color: var(--text); }
        .mode-tab.active { background: rgba(0,212,255,0.15); border-color: var(--accent); color: var(--text); }
        .mode-tab.janus.active { background: rgba(96,64,255,0.15); border-color: var(--ocean); }
        
        /* Scenarios */
        .scenario-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
        
        .scenario-btn {
            padding: 10px 6px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--dim);
            font-size: 9px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .scenario-btn:hover { border-color: var(--accent); color: var(--text); }
        .scenario-btn.active { background: rgba(0,212,255,0.1); border-color: var(--accent); color: var(--accent); }
        .scenario-btn .icon { font-size: 16px; display: block; margin-bottom: 4px; }
        
        /* Controls */
        .control-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .control-label { font-size: 10px; min-width: 90px; }
        .control-value { font-family: monospace; font-size: 10px; color: var(--accent); min-width: 40px; text-align: right; }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px; height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .btn-row { display: flex; gap: 4px; margin-top: 8px; }
        
        .btn {
            flex: 1;
            padding: 8px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover { border-color: var(--accent); }
        .btn.active { background: rgba(0,212,255,0.15); border-color: var(--accent); }
        
        /* Stats */
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
        
        .stat {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 8px;
        }
        
        .stat-label { font-size: 7px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-family: monospace; font-size: 14px; color: var(--accent); margin-top: 2px; }
        .stat-value.pos { color: var(--positive); }
        .stat-value.neg { color: var(--negative); }
        .stat-value.ocean { color: var(--ocean); }
        
        /* Top bar */
        .top-bar {
            position: fixed;
            top: 10px;
            left: 320px;
            right: 340px;
            padding: 10px 16px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .top-item { text-align: center; }
        .top-label { font-size: 7px; color: var(--dim); text-transform: uppercase; }
        .top-value { font-family: monospace; font-size: 12px; color: var(--accent); }
        
        /* Legend */
        .legend {
            position: fixed;
            bottom: 10px;
            left: 320px;
            padding: 8px 14px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            z-index: 100;
            display: flex;
            gap: 14px;
        }
        
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 9px; color: var(--dim); }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
        
        /* Fullscreen */
        body.fullscreen .panel, body.fullscreen .top-bar, body.fullscreen .legend { display: none !important; }
        .fs-hint { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 8px 16px; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; font-size: 10px; color: var(--dim); z-index: 200; }
        body.fullscreen .fs-hint { display: block; }
        
        /* DESI indicator */
        .desi-badge {
            display: inline-block;
            padding: 2px 6px;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            border-radius: 3px;
            font-size: 8px;
            font-weight: 700;
            color: #000;
            margin-left: 6px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="fs-hint">Appuyez sur F ou ESC pour quitter</div>
    
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="top-item">
            <div class="top-label">Mode</div>
            <div class="top-value" id="top-mode">JANUS+DESI</div>
        </div>
        <div class="top-item">
            <div class="top-label">Galaxies</div>
            <div class="top-value" id="top-galaxies">0</div>
        </div>
        <div class="top-item">
            <div class="top-label">Densit√© Oc√©an m‚Åª</div>
            <div class="top-value" id="top-ocean">0</div>
        </div>
        <div class="top-item">
            <div class="top-label">Pression</div>
            <div class="top-value" id="top-pressure">0</div>
        </div>
        <div class="top-item">
            <div class="top-label">Temps</div>
            <div class="top-value" id="top-time">0 Gyr</div>
        </div>
        <div class="top-item">
            <div class="top-label">Acc√©l√©ration</div>
            <div class="top-value" id="top-accel">0</div>
        </div>
        <div class="top-item">
            <div class="top-label">FPS</div>
            <div class="top-value" id="top-fps">60</div>
        </div>
    </div>
    
    <!-- Left Panel -->
    <div class="panel panel-left">
        <h1>JANUS v4</h1>
        <div class="subtitle">COSMOLOGIE BIM√âTRIQUE ‚Äî DONN√âES DESI 2024-2025</div>
        
        <!-- Mode Selection -->
        <div class="section">
            <div class="section-title">Mode de Simulation</div>
            <div class="mode-tabs">
                <div class="mode-tab" id="tab-standard" onclick="setMode('standard')">
                    <div>Standard</div>
                    <div style="font-size:7px;color:var(--negative)">ŒõCDM+triche</div>
                </div>
                <div class="mode-tab" id="tab-relativity" onclick="setMode('relativity')">
                    <div>Relativit√©</div>
                    <div style="font-size:7px;color:var(--negative)">S'effondre</div>
                </div>
                <div class="mode-tab janus active" id="tab-janus" onclick="setMode('janus')">
                    <div>Janus+DESI</div>
                    <div style="font-size:7px;color:var(--positive)">Stable ‚úì</div>
                </div>
            </div>
        </div>
        
        <!-- DESI Info -->
        <div class="section" id="desi-section">
            <div class="section-title">R√©sultats DESI 2024-2025 <span class="desi-badge">NEW</span></div>
            <div class="card desi">
                <div class="card-title">üìä L'√©nergie sombre √âVOLUE</div>
                <div class="note">
                    DESI a montr√© que l'√©nergie sombre n'est <strong>PAS constante</strong> (Œõ).<br><br>
                    ‚Üí Elle <strong>s'affaiblit</strong> ou <strong>se renforce</strong> avec le temps<br>
                    ‚Üí Le mod√®le ŒõCDM montre des "fissures"<br>
                    ‚Üí <strong>Janus pr√©dit exactement cela !</strong>
                </div>
            </div>
        </div>
        
        <!-- Physics Explanation -->
        <div class="section">
            <div class="section-title">Physique Janus</div>
            
            <div class="card janus">
                <div class="card-title">üåä L'Oc√©an de Masse N√©gative</div>
                <div class="note">
                    <strong>95% de l'univers</strong> = oc√©an m‚Åª (invisible)<br>
                    <strong>5% mati√®re visible</strong> = galaxies immerg√©es<br><br>
                    Cet oc√©an exerce une <strong>PRESSION ISOTROPE</strong> qui :<br>
                    ‚Ä¢ Confine les galaxies<br>
                    ‚Ä¢ Les aplatit en disques<br>
                    ‚Ä¢ Emp√™che leur fusion
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">‚ö´ Voids & Conglom√©rats m‚Åª</div>
                <div class="note">
                    Les grands <strong>VOIDS</strong> cosmiques contiennent des <strong>conglom√©rats de masse n√©gative</strong> (invisibles).<br><br>
                    Ex: Le <strong>Dipole Repeller</strong> = amas m‚Åª qui repousse les galaxies.
                </div>
            </div>
            
            <div class="card">
                <div class="card-title">üï≥Ô∏è Trou Noir Central (Sgr A*)</div>
                <div class="eq">M_SgrA* ‚âà 4√ó10‚Å∂ M‚òâ</div>
                <div class="note">
                    Chaque galaxie a un trou noir supermassif au centre qui interagit avec l'oc√©an m‚Åª.
                </div>
            </div>
        </div>
        
        <!-- Scenarios -->
        <div class="section">
            <div class="section-title">Sc√©narios</div>
            <div class="scenario-grid">
                <div class="scenario-btn active" id="sc-observable" onclick="loadScenario('observable')">
                    <span class="icon">üî≠</span>
                    Univers Observable
                </div>
                <div class="scenario-btn" id="sc-bigbang" onclick="loadScenario('bigbang')">
                    <span class="icon">üí•</span>
                    Big Bang
                </div>
                <div class="scenario-btn" id="sc-milkyway" onclick="loadScenario('milkyway')">
                    <span class="icon">üåÄ</span>
                    Voie Lact√©e
                </div>
                <div class="scenario-btn" id="sc-desi" onclick="loadScenario('desi')">
                    <span class="icon">üìà</span>
                    Test DESI
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="section">
            <div class="section-title">Param√®tres</div>
            
            <div class="control-row">
                <span class="control-label">Vitesse</span>
                <input type="range" id="ctrl-speed" min="0" max="5" step="0.1" value="1">
                <span class="control-value" id="val-speed">1.0√ó</span>
            </div>
            
            <div class="control-row">
                <span class="control-label">Gravit√© G</span>
                <input type="range" id="ctrl-gravity" min="0.1" max="3" step="0.1" value="1">
                <span class="control-value" id="val-gravity">1.0</span>
            </div>
            
            <div class="control-row">
                <span class="control-label">Ratio m‚Åª/m‚Å∫</span>
                <input type="range" id="ctrl-ratio" min="10" max="100" step="5" value="50">
                <span class="control-value" id="val-ratio">50√ó</span>
            </div>
            
            <div class="control-row">
                <span class="control-label">Pression Oc√©an</span>
                <input type="range" id="ctrl-pressure" min="0" max="10" step="0.5" value="5">
                <span class="control-value" id="val-pressure">5.0</span>
            </div>
            
            <div class="control-row">
                <span class="control-label">√âvolution w(t)</span>
                <input type="range" id="ctrl-evolution" min="0" max="5" step="0.1" value="2">
                <span class="control-value" id="val-evolution">2.0</span>
            </div>
            
            <div class="btn-row">
                <button class="btn active" id="btn-pause" onclick="togglePause()">‚è∏ Pause</button>
                <button class="btn" onclick="reset()">‚Üª Reset</button>
                <button class="btn" onclick="toggleFS()">‚õ∂ Plein</button>
            </div>
        </div>
    </div>
    
    <!-- Right Panel -->
    <div class="panel panel-right">
        <div class="section">
            <div class="section-title">Statistiques Univers</div>
            <div class="stats-grid">
                <div class="stat">
                    <div class="stat-label">Galaxies m‚Å∫</div>
                    <div class="stat-value pos" id="stat-galaxies">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Masse Totale m‚Å∫</div>
                    <div class="stat-value pos" id="stat-mass-pos">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Masse Oc√©an m‚Åª</div>
                    <div class="stat-value ocean" id="stat-mass-neg">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Voids D√©tect√©s</div>
                    <div class="stat-value" id="stat-voids">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Pression Moyenne</div>
                    <div class="stat-value" id="stat-pressure">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Stabilit√©</div>
                    <div class="stat-value" id="stat-stability">0%</div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">√âquilibre des Forces</div>
            <div class="card">
                <div style="display:flex;justify-content:space-between;margin-bottom:6px;">
                    <span style="color:var(--positive)">Gravit√© (attraction)</span>
                    <span id="force-grav">0</span>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:6px;">
                    <span style="color:var(--ocean)">Pression oc√©an m‚Åª</span>
                    <span id="force-ocean">0</span>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:6px;">
                    <span style="color:var(--blackhole)">Trou noir central</span>
                    <span id="force-bh">0</span>
                </div>
                <div style="display:flex;justify-content:space-between;border-top:1px solid var(--border);padding-top:6px;margin-top:6px;">
                    <span style="font-weight:600">√âtat</span>
                    <span id="state" style="color:var(--positive)">--</span>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">üéØ Preuve DESI: Vitesse par Zone</div>
            <div class="card desi">
                <div class="note" style="margin-bottom:8px;">
                    Si Janus est correct, les galaxies <strong>LOINTAINES</strong> doivent aller <strong>PLUS VITE</strong> que les proches (plus de vide = plus d'acc√©l√©ration).
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                    <span>Galaxies proches (&lt;150)</span>
                    <span id="vel-inner" style="color:var(--accent)">--</span>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                    <span>Galaxies lointaines (&gt;150)</span>
                    <span id="vel-outer" style="color:var(--accent)">--</span>
                </div>
                <div style="display:flex;justify-content:space-between;border-top:1px solid var(--border);padding-top:6px;margin-top:6px;">
                    <span style="font-weight:600">Ratio (doit √™tre &gt;1)</span>
                    <span id="vel-ratio" style="color:var(--positive);font-weight:700">--</span>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Pr√©dictions V√©rifi√©es</div>
            <div class="card">
                <div id="pred-flat" style="margin-bottom:4px;">‚è≥ Courbes rotation plates</div>
                <div id="pred-stable" style="margin-bottom:4px;">‚è≥ Galaxies stables</div>
                <div id="pred-disk" style="margin-bottom:4px;">‚è≥ Galaxies aplaties</div>
                <div id="pred-accel" style="margin-bottom:4px;">‚è≥ Expansion acc√©l√©r√©e</div>
                <div id="pred-desi" style="margin-bottom:4px;">‚è≥ w(t) √©volutif (DESI)</div>
                <div id="pred-voids">‚è≥ Structure lacunaire</div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Comparaison des Mod√®les</div>
            <div class="card">
                <table style="width:100%;font-size:8px;border-collapse:collapse;">
                    <tr style="border-bottom:1px solid var(--border);">
                        <th style="text-align:left;padding:3px;">Aspect</th>
                        <th style="padding:3px;">ŒõCDM</th>
                        <th style="padding:3px;">Janus</th>
                    </tr>
                    <tr>
                        <td style="padding:3px;">Mati√®re noire</td>
                        <td style="padding:3px;text-align:center;color:var(--negative)">27% ?</td>
                        <td style="padding:3px;text-align:center;color:var(--positive)">Non</td>
                    </tr>
                    <tr>
                        <td style="padding:3px;">√ânergie sombre</td>
                        <td style="padding:3px;text-align:center;color:var(--negative)">68% ?</td>
                        <td style="padding:3px;text-align:center;color:var(--positive)">Oc√©an m‚Åª</td>
                    </tr>
                    <tr>
                        <td style="padding:3px;">Stabilit√©</td>
                        <td style="padding:3px;text-align:center;color:var(--negative)">Triche</td>
                        <td style="padding:3px;text-align:center;color:var(--positive)">Naturelle</td>
                    </tr>
                    <tr>
                        <td style="padding:3px;">w(t) √©volutif</td>
                        <td style="padding:3px;text-align:center;color:var(--negative)">Non</td>
                        <td style="padding:3px;text-align:center;color:var(--positive)">Oui ‚úì</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Legend -->
    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--accent);"></div>Galaxie lente</div>
        <div class="legend-item"><div class="legend-dot" style="background:linear-gradient(90deg, #00d4ff, #ffaa00);"></div>‚Üí acc√©l√®re</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff6644;"></div>Galaxie rapide</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--ocean);"></div>Oc√©an m‚Åª</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--void);"></div>Void</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--blackhole);"></div>Trou Noir</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // JANUS v4 ‚Äî COSMOLOGIE BIM√âTRIQUE + DESI 2024-2025
        // Based on Jean-Pierre Petit's research & DESI collaboration results
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const PHYSICS = {
            G: 1.0,
            SOFTENING: 8.0,
            DT: 0.008,              // Plus petit pour stabilit√© √† haute vitesse
            UNIVERSE_RADIUS: 2000,  // 4√ó plus grand!
            VOID_RADIUS: 150,
            BLACK_HOLE_MASS: 3000,
            GALAXY_SCALE: 0.4,      // Galaxies plus petites
        };
        
        const CONFIG = {
            mode: 'janus',
            speed: 1.0,
            gravity: 1.0,
            massRatio: 50,          // m‚Åª/m‚Å∫ ratio (95%/5%)
            oceanPressure: 5.0,     // Augment√© pour √©quilibrer gravit√©
            darkEnergyEvolution: 2.0,  // w(t) plus fort pour acc√©l√©ration visible
            paused: false,
            scenario: 'observable',
        };
        
        const UNIVERSE = {
            galaxies: [],
            voids: [],
            blackHoles: [],
            oceanParticles: null,
            time: 0,
            cosmicTime: 0,  // In Gyr
            avgPressure: 0,
            totalAcceleration: 0,
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THREE.JS SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020306);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 10000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Groups
        const galaxyGroup = new THREE.Group();
        const oceanGroup = new THREE.Group();
        const voidGroup = new THREE.Group();
        const blackHoleGroup = new THREE.Group();
        scene.add(galaxyGroup, oceanGroup, voidGroup, blackHoleGroup);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GALAXY CLASS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        class Galaxy {
            constructor(mass, pos, vel) {
                this.mass = mass;
                this.position = pos.clone();
                this.velocity = vel.clone();
                this.force = new THREE.Vector3();
                // Galaxies plus petites avec GALAXY_SCALE
                this.radius = Math.pow(mass, 0.25) * 1.5 * (PHYSICS.GALAXY_SCALE || 0.4);
                this.hasBlackHole = mass > 200;
                this.blackHoleMass = this.hasBlackHole ? mass * 0.01 : 0;
                
                this.createMesh();
            }
            
            createMesh() {
                const group = new THREE.Group();
                const scale = PHYSICS.GALAXY_SCALE || 0.4;
                
                // Galaxy core - plus petit
                const coreGeom = new THREE.SphereGeometry(this.radius * 0.3, 12, 12);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0x00d4ff });
                group.add(new THREE.Mesh(coreGeom, coreMat));
                
                // Black hole at center (if massive enough)
                if (this.hasBlackHole) {
                    const bhGeom = new THREE.SphereGeometry(this.radius * 0.08, 12, 12);
                    const bhMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const bh = new THREE.Mesh(bhGeom, bhMat);
                    group.add(bh);
                    
                    // Accretion disk
                    const diskGeom = new THREE.RingGeometry(this.radius * 0.1, this.radius * 0.25, 32);
                    const diskMat = new THREE.MeshBasicMaterial({ 
                        color: 0xff8800, 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.DoubleSide 
                    });
                    const disk = new THREE.Mesh(diskGeom, diskMat);
                    disk.rotation.x = Math.PI / 2;
                    group.add(disk);
                }
                
                // Galactic disk (flat!)
                const diskGeom = new THREE.RingGeometry(this.radius * 0.3, this.radius * 1.5, 48);
                const diskMat = new THREE.MeshBasicMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.25,
                    side: THREE.DoubleSide
                });
                const galDisk = new THREE.Mesh(diskGeom, diskMat);
                galDisk.rotation.x = Math.PI / 2;
                group.add(galDisk);
                
                // Spiral arms
                const armGeom = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (let arm = 0; arm < 2; arm++) {
                    for (let i = 0; i < 80; i++) {
                        const t = (i / 80) * Math.PI * 2.5;
                        const r = this.radius * 0.2 + t * this.radius * 0.2;
                        const theta = t + arm * Math.PI;
                        const spread = 0.3 + t * 0.1;
                        
                        positions.push(
                            r * Math.cos(theta) + (Math.random() - 0.5) * spread,
                            (Math.random() - 0.5) * 0.15,  // Very flat!
                            r * Math.sin(theta) + (Math.random() - 0.5) * spread
                        );
                        
                        const brightness = 0.5 + Math.random() * 0.5;
                        colors.push(0, brightness, brightness);
                    }
                }
                
                armGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                armGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const armMat = new THREE.PointsMaterial({
                    size: 0.4,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });
                group.add(new THREE.Points(armGeom, armMat));
                
                group.position.copy(this.position);
                this.mesh = group;
                galaxyGroup.add(group);
            }
            
            update() {
                if (this.mesh) {
                    this.mesh.position.copy(this.position);
                    this.mesh.rotation.y += 0.003 * CONFIG.speed;
                    
                    // Color based on velocity (shows acceleration!)
                    const speed = this.velocity.length();
                    const maxSpeed = 5;
                    const speedRatio = Math.min(1, speed / maxSpeed);
                    
                    // Slow = cyan, Fast = yellow/red
                    const r = speedRatio;
                    const g = 0.8 - speedRatio * 0.5;
                    const b = 1 - speedRatio;
                    
                    // Update core color
                    if (this.mesh.children[0] && this.mesh.children[0].material) {
                        this.mesh.children[0].material.color.setRGB(r, g, b);
                    }
                    
                    // Update trail/halo based on local ocean density
                    if (this.localOceanDensity !== undefined) {
                        const oceanIntensity = this.localOceanDensity / (CONFIG.massRatio * 1.5);
                        // Could add visual effect here
                    }
                }
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VOID CLASS (cosmic voids with negative mass concentration)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        class Void {
            constructor(pos, radius, negativeMass) {
                this.position = pos.clone();
                this.radius = radius;
                this.negativeMass = negativeMass;
                
                this.createMesh();
            }
            
            createMesh() {
                // Void sphere (semi-transparent dark region)
                const geom = new THREE.SphereGeometry(this.radius, 24, 24);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0x200840,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                
                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.position.copy(this.position);
                
                // Negative mass concentration at center (invisible but represented)
                const centerGeom = new THREE.SphereGeometry(this.radius * 0.3, 16, 16);
                const centerMat = new THREE.MeshBasicMaterial({
                    color: 0x4020ff,
                    transparent: true,
                    opacity: 0.1
                });
                const center = new THREE.Mesh(centerGeom, centerMat);
                this.mesh.add(center);
                
                voidGroup.add(this.mesh);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // OCEAN OF NEGATIVE MASS (continuous fluid)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function createOcean() {
            oceanGroup.clear();
            
            // Particules de l'oc√©an de masse n√©gative - adapt√© au grand univers
            const particleCount = 8000;  // Plus de particules
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * PHYSICS.UNIVERSE_RADIUS;
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = (Math.random() - 0.5) * 200;  // Plus d'espace vertical
                const z = r * Math.sin(phi) * Math.sin(theta);
                
                positions.push(x, y, z);
                
                // Couleur violet-bleu pour masse n√©gative
                colors.push(0.3 + Math.random() * 0.2, 0.1, 0.5 + Math.random() * 0.3);
            }
            
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 1.5,  // L√©g√®rement plus gros pour visibilit√© √† distance
                vertexColors: true,
                transparent: true,
                opacity: 0.12
            });
            
            UNIVERSE.oceanParticles = new THREE.Points(geom, mat);
            oceanGroup.add(UNIVERSE.oceanParticles);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHYSICS ENGINE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function computeForces() {
            UNIVERSE.galaxies.forEach(g => g.force.set(0, 0, 0));
            
            if (CONFIG.mode === 'standard') {
                computeStandardForces();
            } else if (CONFIG.mode === 'relativity') {
                computeRelativityForces();
            } else {
                computeJanusForces();
            }
        }
        
        function computeStandardForces() {
            // ŒõCDM with artificial stabilization (cheating!)
            const galaxies = UNIVERSE.galaxies;
            
            for (let i = 0; i < galaxies.length; i++) {
                for (let j = i + 1; j < galaxies.length; j++) {
                    const g1 = galaxies[i];
                    const g2 = galaxies[j];
                    
                    const r = new THREE.Vector3().subVectors(g2.position, g1.position);
                    const dist = Math.max(r.length(), PHYSICS.SOFTENING);
                    r.normalize();
                    
                    // Gravity + fake dark matter halo
                    let F = PHYSICS.G * CONFIG.gravity * g1.mass * g2.mass / (dist * dist);
                    F -= 0.02 * g1.mass * g2.mass / (dist * dist * dist);  // FAKE!
                    
                    const force = r.multiplyScalar(F);
                    g1.force.add(force);
                    g2.force.sub(force);
                }
                
                // Fake dark energy expansion
                const hubble = 0.00005 * CONFIG.darkEnergyEvolution;
                galaxies[i].force.add(
                    new THREE.Vector3(galaxies[i].position.x, 0, galaxies[i].position.z)
                    .multiplyScalar(hubble * galaxies[i].mass)
                );
            }
        }
        
        function computeRelativityForces() {
            // Pure Newton/Einstein - NO stabilization = COLLAPSE!
            const galaxies = UNIVERSE.galaxies;
            
            for (let i = 0; i < galaxies.length; i++) {
                for (let j = i + 1; j < galaxies.length; j++) {
                    const g1 = galaxies[i];
                    const g2 = galaxies[j];
                    
                    const r = new THREE.Vector3().subVectors(g2.position, g1.position);
                    const dist = Math.max(r.length(), PHYSICS.SOFTENING);
                    r.normalize();
                    
                    // Pure gravity only
                    const F = PHYSICS.G * CONFIG.gravity * g1.mass * g2.mass / (dist * dist);
                    
                    const force = r.multiplyScalar(F);
                    g1.force.add(force);
                    g2.force.sub(force);
                }
            }
        }
        
        function computeJanusForces() {
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // JANUS v4-FIXED: Pression Diff√©rentielle + DESI 2024-2025
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            //
            // PHYSIQUE CL√â (corrig√©e):
            // 
            // 1. STABILIT√â LOCAL: Pression DIFF√âRENTIELLE emp√™che fusion
            //    - 2 galaxies proches = moins d'oc√©an ENTRE elles
            //    - L'oc√©an AUTOUR exerce une pression vers l'int√©rieur
            //    - P_externe > P_entre ‚Üí R√âPULSION qui stabilise!
            //
            // 2. ACC√âL√âRATION COSMIQUE (DESI):
            //    - Plus une galaxie est LOIN ‚Üí Plus d'oc√©an cumul√©
            //    - R√©pulsion ‚àù distance ‚Üí expansion ACC√âL√âR√âE!
            //
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            const galaxies = UNIVERSE.galaxies;
            const oceanBaseDensity = CONFIG.massRatio;
            const pressureCoeff = CONFIG.oceanPressure;
            const wEvolution = CONFIG.darkEnergyEvolution;
            
            // Time-dependent w(t) from DESI - √©volution de l'√©nergie noire
            const cosmicAge = UNIVERSE.cosmicTime;
            const wFactor = 1 + 0.2 * wEvolution * (1 - Math.exp(-cosmicAge * 0.05));
            
            let totalGrav = 0, totalOcean = 0, totalBH = 0;
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 1: Calculate LOCAL MATTER DENSITY
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            galaxies.forEach(g => {
                g.localMatterDensity = 0;
                g.localOceanDensity = oceanBaseDensity;
            });
            
            for (let i = 0; i < galaxies.length; i++) {
                for (let j = 0; j < galaxies.length; j++) {
                    if (i === j) continue;
                    const dist = galaxies[i].position.distanceTo(galaxies[j].position);
                    const contribution = galaxies[j].mass / (dist * dist + 100);
                    galaxies[i].localMatterDensity += contribution;
                }
            }
            
            let maxDensity = 0;
            galaxies.forEach(g => { if (g.localMatterDensity > maxDensity) maxDensity = g.localMatterDensity; });
            
            galaxies.forEach(g => {
                const normalizedMatter = maxDensity > 0 ? g.localMatterDensity / maxDensity : 0;
                g.localOceanDensity = oceanBaseDensity * (1 - normalizedMatter * 0.6) * wFactor;
            });
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 2: Apply forces
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            for (let i = 0; i < galaxies.length; i++) {
                const g1 = galaxies[i];
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 2a. GRAVITY + OCEAN PRESSURE (PRESSION DIFF√âRENTIELLE!)
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                for (let j = i + 1; j < galaxies.length; j++) {
                    const g2 = galaxies[j];
                    
                    const r = new THREE.Vector3().subVectors(g2.position, g1.position);
                    const dist = Math.max(r.length(), PHYSICS.SOFTENING);
                    const rNorm = r.clone().normalize();
                    
                    // Newton gravity (attraction)
                    const F_grav = PHYSICS.G * CONFIG.gravity * g1.mass * g2.mass / (dist * dist);
                    totalGrav += F_grav;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // PRESSION DIFF√âRENTIELLE (mod√®le v3 corrig√© + calibr√©)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // L'oc√©an de masse n√©gative (95% de l'univers) exerce une
                    // pression qui doit √âQUILIBRER la gravit√© naturellement.
                    //
                    // Calibration: La pression doit √™tre comparable √† la gravit√©
                    // donc on utilise aussi m1√óm2 (pas m1+m2)
                    
                    const r1 = g1.radius || Math.pow(g1.mass, 0.25) * 1.5;
                    const r2 = g2.radius || Math.pow(g2.mass, 0.25) * 1.5;
                    
                    // Volume exclu: plus les galaxies sont proches, plus grand
                    const excludedVolume = (r1 + r2) * (r1 + r2) / (dist + 1);
                    
                    // Pression de base de l'oc√©an (proportionnelle √† la densit√©)
                    const avgOceanDensity = (g1.localOceanDensity + g2.localOceanDensity) / 2;
                    const P_base = avgOceanDensity * pressureCoeff * 0.1;  // Normalis√©
                    
                    // Pression ENTRE les galaxies (r√©duite par l'exclusion)
                    const P_between = P_base * Math.max(0, 1 - excludedVolume / (dist + 5));
                    
                    // Diff√©rence de pression ‚Üí R√âPULSION
                    // Utilise m1√óm2 pour √©quilibrer la gravit√©!
                    const P_diff = Math.max(0, P_base - P_between);
                    const F_ocean = P_diff * g1.mass * g2.mass / (dist * dist + 100);
                    totalOcean += F_ocean;
                    
                    // Force nette: gravit√© (attraction) - oc√©an (r√©pulsion)
                    const F_net = F_grav - F_ocean;
                    const force = rNorm.multiplyScalar(F_net);
                    g1.force.add(force);
                    g2.force.sub(force);
                }
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 2b. VOID REPULSION - Les vides sont PLEINS d'oc√©an!
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                UNIVERSE.voids.forEach(v => {
                    const r = new THREE.Vector3().subVectors(g1.position, v.position);
                    const dist = Math.max(r.length(), PHYSICS.SOFTENING);
                    const rNorm = r.clone().normalize();
                    
                    // Les vides ont une concentration maximale de masse n√©gative
                    const voidOceanDensity = oceanBaseDensity * 2.0 * wFactor;
                    const F_void = voidOceanDensity * v.negativeMass * g1.mass / (dist * dist + 200);
                    
                    // Coefficient augment√© pour effet visible
                    g1.force.add(rNorm.multiplyScalar(F_void * 0.05));
                    totalOcean += F_void * 0.05;
                });
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 2c. EXPANSION COSMIQUE ACC√âL√âR√âE (DESI 2024)
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // PHYSIQUE CL√â:
                // - Plus une galaxie est loin ‚Üí plus d'oc√©an travers√©
                // - Plus elle est isol√©e ‚Üí plus la densit√© oc√©an est haute
                // - ACC√âL√âRATION = Force qui AUGMENTE avec la distance!
                //
                // F ‚àù r √ó œÅ_oc√©an¬≤ ‚Üí v augmente avec r ‚Üí ACC√âL√âRATION!
                
                const radialDist = Math.sqrt(g1.position.x * g1.position.x + g1.position.z * g1.position.z);
                
                // Normaliser la distance par rapport √† l'univers
                const normalizedDist = radialDist / PHYSICS.UNIVERSE_RADIUS;
                
                // Densit√© oc√©an normalis√©e (haute dans les vides, basse pr√®s des amas)
                const oceanFactor = g1.localOceanDensity / oceanBaseDensity;
                
                // ACC√âL√âRATION: force qui cro√Æt avec la distance!
                // Coefficients augment√©s pour effet visible
                const linearTerm = radialDist * oceanFactor;
                const accelTerm = radialDist * normalizedDist * oceanFactor * oceanFactor;
                
                // Coefficients calibr√©s pour √©quilibrer avec gravit√© √† 1.0
                const expansionForce = (linearTerm * 0.0001 + accelTerm * 0.0003) * g1.mass * wFactor;
                
                const radialDir = new THREE.Vector3(g1.position.x, 0, g1.position.z).normalize();
                g1.force.add(radialDir.multiplyScalar(expansionForce));
                totalOcean += expansionForce;
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 2d. COMPRESSION VERTICALE (galaxies plates)
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const targetY = 0;
                const yDiff = targetY - g1.position.y;
                const F_y = pressureCoeff * g1.mass * yDiff * 0.015;
                g1.force.y += F_y;
                g1.velocity.y *= 0.9;
                
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // 2e. BLACK HOLE contribution
                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if (g1.hasBlackHole) {
                    totalBH += g1.blackHoleMass * 0.001 * g1.mass;
                }
            }
            
            // Update stats
            UNIVERSE.avgPressure = totalOcean / Math.max(1, galaxies.length);
            UNIVERSE.totalAcceleration = totalOcean - totalGrav;
            
            document.getElementById('force-grav').textContent = totalGrav.toFixed(1);
            document.getElementById('force-ocean').textContent = totalOcean.toFixed(1);
            document.getElementById('force-bh').textContent = totalBH.toFixed(1);
            
            const ratio = totalOcean / (totalGrav + 0.01);
            let state = '';
            if (ratio > 1.5) state = 'üîµ EXPANSION ACC√âL√âR√âE';
            else if (ratio > 0.9) state = '‚úÖ √âQUILIBRE DYNAMIQUE';
            else if (ratio > 0.5) state = '‚ö†Ô∏è EXPANSION MOD√âR√âE';
            else state = '‚ùå CONTRACTION';
            document.getElementById('state').textContent = state;
        }
        
        function integrate() {
            const dt = PHYSICS.DT * CONFIG.speed;
            const damping = CONFIG.mode === 'janus' ? 0.998 : 0.999;
            
            UNIVERSE.galaxies.forEach(g => {
                const accel = g.force.clone().divideScalar(g.mass);
                g.velocity.add(accel.multiplyScalar(dt));
                g.velocity.multiplyScalar(damping);
                g.position.add(g.velocity.clone().multiplyScalar(dt));
                
                // Soft boundary - galaxies ralentissent pr√®s du bord mais ne disparaissent pas
                const r = Math.sqrt(g.position.x * g.position.x + g.position.z * g.position.z);
                if (r > PHYSICS.UNIVERSE_RADIUS * 0.9) {
                    // Ralentir doucement pr√®s du bord (pas de spawn!)
                    const edgeFactor = (r - PHYSICS.UNIVERSE_RADIUS * 0.9) / (PHYSICS.UNIVERSE_RADIUS * 0.1);
                    g.velocity.multiplyScalar(1 - edgeFactor * 0.1);
                }
                
                // Hard limit
                if (r > PHYSICS.UNIVERSE_RADIUS) {
                    g.position.x *= PHYSICS.UNIVERSE_RADIUS / r;
                    g.position.z *= PHYSICS.UNIVERSE_RADIUS / r;
                    g.velocity.x *= -0.3;
                    g.velocity.z *= -0.3;
                }
                
                g.update();
            });
            
            UNIVERSE.time += dt;
            UNIVERSE.cosmicTime += dt * 0.1;
        }
        
        // Fonction spawn gard√©e mais plus appel√©e automatiquement
        function spawnNewGalaxy() {
            // Spawn at edge coming inward (for continuous observation)
            const angle = Math.random() * Math.PI * 2;
            const r = PHYSICS.UNIVERSE_RADIUS * 0.3;
            const mass = 100 + Math.random() * 600;
            
            const pos = new THREE.Vector3(
                r * Math.cos(angle),
                (Math.random() - 0.5) * 10,
                r * Math.sin(angle)
            );
            
            // Orbital velocity
            const speed = Math.sqrt(PHYSICS.G * 5000 / r) * 0.15;
            const vel = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).multiplyScalar(speed);
            
            const galaxy = new Galaxy(mass, pos, vel);
            UNIVERSE.galaxies.push(galaxy);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SCENARIOS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function clearUniverse() {
            UNIVERSE.galaxies.forEach(g => galaxyGroup.remove(g.mesh));
            UNIVERSE.voids.forEach(v => voidGroup.remove(v.mesh));
            UNIVERSE.galaxies = [];
            UNIVERSE.voids = [];
            UNIVERSE.time = 0;
            UNIVERSE.cosmicTime = 0;
        }
        
        function loadScenario(name) {
            clearUniverse();
            CONFIG.scenario = name;
            
            document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('sc-' + name)?.classList.add('active');
            
            createOcean();
            
            switch(name) {
                case 'observable': createObservableUniverse(); break;
                case 'bigbang': createBigBang(); break;
                case 'milkyway': createMilkyWay(); break;
                case 'desi': createDESITest(); break;
            }
        }
        
        function createObservableUniverse() {
            // Grand univers avec structure √† grande √©chelle
            const galaxyCount = 60;  // Plus de galaxies!
            
            // Cr√©er des vides cosmiques √† grande √©chelle
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                const r = 400 + Math.random() * 800;  // Plus loin
                const pos = new THREE.Vector3(
                    r * Math.cos(angle),
                    (Math.random() - 0.5) * 60,
                    r * Math.sin(angle)
                );
                const v = new Void(pos, 120 + Math.random() * 100, 3000 + Math.random() * 4000);
                UNIVERSE.voids.push(v);
            }
            
            // Galaxies r√©parties dans tout l'univers
            for (let i = 0; i < galaxyCount; i++) {
                let pos, attempts = 0;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 100 + Math.random() * 1600;  // Jusqu'au bord
                    pos = new THREE.Vector3(
                        r * Math.cos(angle) + (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 30,
                        r * Math.sin(angle) + (Math.random() - 0.5) * 100
                    );
                    attempts++;
                } while (isInVoid(pos) && attempts < 30);
                
                const mass = 80 + Math.random() * 400;  // Masses vari√©es
                // Vitesse orbitale faible
                const speed = Math.sqrt(PHYSICS.G * 1000 / Math.max(100, pos.length())) * 0.08;
                const vel = new THREE.Vector3(-pos.z, 0, pos.x).normalize().multiplyScalar(speed);
                
                UNIVERSE.galaxies.push(new Galaxy(mass, pos, vel));
            }
        }
        
        function isInVoid(pos) {
            for (const v of UNIVERSE.voids) {
                if (pos.distanceTo(v.position) < v.radius * 0.7) return true;
            }
            return false;
        }
        
        function createBigBang() {
            // Big Bang: commence concentr√© puis ACC√âL√àRE vers l'ext√©rieur
            const count = 50;
            
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const r = Math.random() * 80;  // Cluster initial
                const mass = 60 + Math.random() * 300;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(theta),
                    (Math.random() - 0.5) * 5,
                    r * Math.sin(theta)
                );
                
                // Vitesse initiale tr√®s faible - l'oc√©an va les acc√©l√©rer!
                const vel = pos.clone().normalize().multiplyScalar(0.05 + Math.random() * 0.1);
                vel.y = 0;
                
                UNIVERSE.galaxies.push(new Galaxy(mass, pos, vel));
            }
        }
        
        function createMilkyWay() {
            // Vue d√©taill√©e avec courbe de rotation plate
            
            // Trou noir central (Sgr A*)
            const sgrA = new Galaxy(PHYSICS.BLACK_HOLE_MASS, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0));
            sgrA.hasBlackHole = true;
            sgrA.blackHoleMass = PHYSICS.BLACK_HOLE_MASS;
            UNIVERSE.galaxies.push(sgrA);
            
            // √âtoiles/amas √† diff√©rents rayons - courbe de rotation PLATE!
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 50 + Math.random() * 600;  // Plus √©tendu
                const mass = 10 + Math.random() * 50;
                
                const pos = new THREE.Vector3(
                    r * Math.cos(angle),
                    (Math.random() - 0.5) * 3,  // Disque plat
                    r * Math.sin(angle)
                );
                
                // Vitesse de rotation CONSTANTE quel que soit le rayon
                const vFlat = 1.8;
                const vel = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle)).multiplyScalar(vFlat);
                
                UNIVERSE.galaxies.push(new Galaxy(mass, pos, vel));
            }
        }
        
        function createDESITest() {
            // Test DESI: montrer l'ACC√âL√âRATION avec la distance
            // Galaxies proches = lentes, galaxies lointaines = ACC√âL√àRENT!
            
            // Anneaux √† diff√©rentes distances - adapt√© au grand univers
            const rings = [
                { r: 150, count: 8, speed: 0.2 },
                { r: 400, count: 10, speed: 0.3 },
                { r: 700, count: 12, speed: 0.4 },
                { r: 1000, count: 10, speed: 0.5 },
                { r: 1400, count: 8, speed: 0.6 },
            ];
            
            rings.forEach(ring => {
                for (let i = 0; i < ring.count; i++) {
                    const angle = (i / ring.count) * Math.PI * 2 + Math.random() * 0.3;
                    const r = ring.r + (Math.random() - 0.5) * 80;
                    const mass = 80 + Math.random() * 250;
                    
                    const pos = new THREE.Vector3(
                        r * Math.cos(angle),
                        (Math.random() - 0.5) * 15,
                        r * Math.sin(angle)
                    );
                    
                    // Vitesse tangentielle + l√©g√®re expansion
                    const tangent = new THREE.Vector3(-Math.sin(angle), 0, Math.cos(angle));
                    const radial = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                    const vel = tangent.multiplyScalar(ring.speed * 0.4).add(radial.multiplyScalar(ring.speed * 0.15));
                    
                    UNIVERSE.galaxies.push(new Galaxy(mass, pos, vel));
                }
            });
            
            // Vides cosmiques entre les anneaux - poussent les galaxies externes!
            const voidPositions = [
                { x: 500, z: 0 },
                { x: -250, z: 430 },
                { x: -250, z: -430 },
                { x: 0, z: 800 },
                { x: 0, z: -800 },
            ];
            
            voidPositions.forEach(vp => {
                const v = new Void(
                    new THREE.Vector3(vp.x, 0, vp.z),
                    100 + Math.random() * 80,
                    2000 + Math.random() * 2000
                );
                UNIVERSE.voids.push(v);
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BACKGROUND
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function createBackground() {
            const geom = new THREE.BufferGeometry();
            const positions = [];
            
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = PHYSICS.UNIVERSE_RADIUS * 2;
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.3 });
            scene.add(new THREE.Points(geom, mat));
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CAMERA CONTROLS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let camTheta = 0.3, camPhi = Math.PI / 2.5, camRadius = 1500;  // Plus loin pour grand univers
        let dragging = false, lastMouse = { x: 0, y: 0 };
        
        function updateCamera() {
            camera.position.x = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
            camera.position.y = camRadius * Math.cos(camPhi);
            camera.position.z = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
            camera.lookAt(0, 0, 0);
        }
        
        canvas.addEventListener('mousedown', e => { dragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
        canvas.addEventListener('mousemove', e => {
            if (!dragging) return;
            camTheta -= (e.clientX - lastMouse.x) * 0.005;
            camPhi = Math.max(0.1, Math.min(Math.PI - 0.1, camPhi + (e.clientY - lastMouse.y) * 0.005));
            lastMouse = { x: e.clientX, y: e.clientY };
            updateCamera();
        });
        canvas.addEventListener('mouseup', () => dragging = false);
        canvas.addEventListener('mouseleave', () => dragging = false);
        canvas.addEventListener('wheel', e => {
            camRadius = Math.max(100, Math.min(5000, camRadius + e.deltaY * 2));  // Zoom plus large
            updateCamera();
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI CONTROLS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setMode(mode) {
            CONFIG.mode = mode;
            document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tab-' + mode)?.classList.add('active');
            document.getElementById('top-mode').textContent = mode === 'janus' ? 'JANUS+DESI' : mode.toUpperCase();
            
            oceanGroup.visible = mode === 'janus';
            voidGroup.visible = mode === 'janus';
            
            reset();
        }
        
        function togglePause() {
            CONFIG.paused = !CONFIG.paused;
            document.getElementById('btn-pause').textContent = CONFIG.paused ? '‚ñ∂ Play' : '‚è∏ Pause';
            document.getElementById('btn-pause').classList.toggle('active', !CONFIG.paused);
        }
        
        function reset() {
            loadScenario(CONFIG.scenario);
        }
        
        function toggleFS() {
            document.body.classList.toggle('fullscreen');
        }
        
        // Sliders
        document.getElementById('ctrl-speed').oninput = function() {
            CONFIG.speed = parseFloat(this.value);
            document.getElementById('val-speed').textContent = CONFIG.speed.toFixed(1) + '√ó';
        };
        
        document.getElementById('ctrl-gravity').oninput = function() {
            CONFIG.gravity = parseFloat(this.value);
            document.getElementById('val-gravity').textContent = CONFIG.gravity.toFixed(1);
        };
        
        document.getElementById('ctrl-ratio').oninput = function() {
            CONFIG.massRatio = parseFloat(this.value);
            document.getElementById('val-ratio').textContent = CONFIG.massRatio + '√ó';
        };
        
        document.getElementById('ctrl-pressure').oninput = function() {
            CONFIG.oceanPressure = parseFloat(this.value);
            document.getElementById('val-pressure').textContent = CONFIG.oceanPressure.toFixed(1);
        };
        
        document.getElementById('ctrl-evolution').oninput = function() {
            CONFIG.darkEnergyEvolution = parseFloat(this.value);
            document.getElementById('val-evolution').textContent = CONFIG.darkEnergyEvolution.toFixed(1);
        };
        
        document.addEventListener('keydown', e => {
            if (e.key === 'f' || e.key === 'F' || e.key === 'Escape') toggleFS();
            if (e.key === ' ') { e.preventDefault(); togglePause(); }
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STATISTICS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function updateStats() {
            const n = UNIVERSE.galaxies.length;
            document.getElementById('stat-galaxies').textContent = n;
            document.getElementById('top-galaxies').textContent = n;
            
            const massPos = UNIVERSE.galaxies.reduce((s, g) => s + g.mass, 0);
            document.getElementById('stat-mass-pos').textContent = Math.round(massPos);
            document.getElementById('stat-mass-neg').textContent = Math.round(massPos * CONFIG.massRatio);
            document.getElementById('top-ocean').textContent = (massPos * CONFIG.massRatio / 1000).toFixed(1) + 'K';
            
            document.getElementById('stat-voids').textContent = UNIVERSE.voids.length;
            document.getElementById('stat-pressure').textContent = UNIVERSE.avgPressure.toFixed(1);
            document.getElementById('top-pressure').textContent = UNIVERSE.avgPressure.toFixed(1);
            
            // VELOCITY BY ZONE - shows acceleration with distance!
            let innerVel = 0, outerVel = 0, innerCount = 0, outerCount = 0;
            const midRadius = PHYSICS.UNIVERSE_RADIUS * 0.35;  // Adapt√© au grand univers
            
            UNIVERSE.galaxies.forEach(g => {
                const r = Math.sqrt(g.position.x * g.position.x + g.position.z * g.position.z);
                const v = g.velocity.length();
                
                if (r < midRadius) {
                    innerVel += v;
                    innerCount++;
                } else {
                    outerVel += v;
                    outerCount++;
                }
            });
            
            innerVel = innerCount > 0 ? innerVel / innerCount : 0;
            outerVel = outerCount > 0 ? outerVel / outerCount : 0;
            
            // Display velocity by zone
            document.getElementById('vel-inner').textContent = innerVel.toFixed(2);
            document.getElementById('vel-outer').textContent = outerVel.toFixed(2);
            const velRatio = innerVel > 0.01 ? (outerVel / innerVel) : 1;
            document.getElementById('vel-ratio').textContent = velRatio.toFixed(2) + '√ó';
            document.getElementById('vel-ratio').style.color = velRatio > 1 ? 'var(--positive)' : 'var(--negative)';
            
            // Stability based on velocity distribution
            let avgVel = 0;
            UNIVERSE.galaxies.forEach(g => avgVel += g.velocity.length());
            avgVel /= Math.max(1, n);
            const stability = Math.max(0, Math.min(100, 100 - avgVel * 20));
            document.getElementById('stat-stability').textContent = Math.round(stability) + '%';
            
            document.getElementById('top-time').textContent = UNIVERSE.cosmicTime.toFixed(1) + ' Gyr';
            
            // Acceleration indicator: outer should be faster than inner!
            const accelRatio = outerCount > 0 && innerCount > 0 ? outerVel / (innerVel + 0.01) : 1;
            const accelSymbol = accelRatio > 1.2 ? '‚Üë‚Üë' : accelRatio > 1 ? '‚Üë' : '‚Üí';
            document.getElementById('top-accel').textContent = accelSymbol + ' ' + accelRatio.toFixed(1) + '√ó';
            
            // Predictions
            const isJanus = CONFIG.mode === 'janus';
            document.getElementById('pred-flat').textContent = isJanus ? '‚úÖ Courbes rotation plates' : '‚ùå Courbes rotation plates';
            document.getElementById('pred-stable').textContent = stability > 60 ? '‚úÖ Galaxies stables' : '‚ùå Galaxies stables';
            document.getElementById('pred-disk').textContent = isJanus ? '‚úÖ Galaxies aplaties' : '‚ö†Ô∏è Galaxies aplaties';
            document.getElementById('pred-accel').textContent = accelRatio > 1 ? '‚úÖ Expansion acc√©l√©r√©e' : '‚ö†Ô∏è Expansion acc√©l√©r√©e';
            document.getElementById('pred-desi').textContent = isJanus && accelRatio > 1.1 ? '‚úÖ w(t) √©volutif (DESI)' : '‚è≥ w(t) √©volutif (DESI)';
            document.getElementById('pred-voids').textContent = UNIVERSE.voids.length > 0 ? '‚úÖ Structure lacunaire' : '‚è≥ Structure lacunaire';
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let lastTime = performance.now();
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                document.getElementById('top-fps').textContent = frameCount;
                frameCount = 0;
                lastTime = now;
            }
            
            if (!CONFIG.paused && UNIVERSE.galaxies.length > 0) {
                computeForces();
                integrate();
                
                if (Math.floor(UNIVERSE.time * 10) % 3 === 0) {
                    updateStats();
                }
            }
            
            // Rotate ocean slowly
            if (UNIVERSE.oceanParticles) {
                UNIVERSE.oceanParticles.rotation.y += 0.0002 * CONFIG.speed;
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INIT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        createBackground();
        updateCamera();
        loadScenario('observable');
        animate();
    </script>
</body>
</html>
